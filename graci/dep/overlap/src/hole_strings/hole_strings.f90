!**********************************************************************
! Routines for the generation of unique sigma-hole strings, i.e., the
! result of the operation of all allowed annihilation operators on the
! set of unique sigma strings
!**********************************************************************
module hole_strings

  implicit none
  
contains

!######################################################################
! get_sigma_holes: given an array of sigma strings, generates all
!                  unique sigma-hole strings
!######################################################################
  subroutine get_sigma_holes(irrepB,irrepK,isigma,nmo,mosym,n_int,&
       nsigma,sigma,nsigmaH,sigmaH,Hinfo_dim,Hinfo)

    use constants

    implicit none

    ! Irrep generated by the wave functions
    integer(is), intent(in)  :: irrepB,irrepK
    
    ! Sigma spin index
    integer(is), intent(in)  :: isigma

    ! Irreps generated by the MOs
    integer(is), intent(in)  :: nmo
    integer(ib), intent(in)  :: mosym(nmo)
    
    ! Number of unique sigma strings
    integer(is), intent(in)  :: nsigma

    ! Unique sigma strings
    integer(is), intent(in)  :: n_int
    integer(ib), intent(in)  :: sigma(n_int,nsigma)

    ! Unique sigma-hole strings
    integer(is), intent(out) :: nsigmaH
    integer(ib), allocatable :: sigmaH(:,:)

    ! Sigma-hole string information
    integer(is), intent(out) :: Hinfo_dim
    integer(is), allocatable :: Hinfo(:,:)
        
    ! Everything else
    integer(ib)              :: iBra,iKet,irrepBK
    
!----------------------------------------------------------------------
! Direct product of the bra and ket wave function irreps
!----------------------------------------------------------------------
    ! Convert the irreps to 64-bit integers
    iBra=irrepB
    iKet=irrepK

    ! Direct product of the irreps
    irrepBK=ieor(iBra,iKet)

!----------------------------------------------------------------------
! (1) Determine the number of unique sigma-hole strings
!----------------------------------------------------------------------
    call get_nsigmaH(n_int,nsigma,sigma,irrepBK,nmo,mosym,nsigmaH,&
         Hinfo_dim)
    
!----------------------------------------------------------------------
! (2) Save the unique sigma-hole strings along with the corresponding
!     lists of annihilation operator indices, parent sigma
!     string indices and phases
!----------------------------------------------------------------------
    allocate(sigmaH(n_int,nsigmaH))
    sigmaH=0_ib
    
    allocate(Hinfo(3,Hinfo_dim))
    Hinfo_dim=0

    call get_hole_strings(n_int,nsigma,sigma,irrepBK,nmo,mosym,&
         nsigmaH,sigmaH,Hinfo_dim,Hinfo)
    
    STOP

    return
    
  end subroutine get_sigma_holes

!######################################################################
! get_nsigmaH: given a set of unique sigma strings + the irreps
!              generated by the bra and ket WFs and MOs, determines
!              the number of unique sigma-hole strings
!######################################################################
  subroutine get_nsigmaH(n_int,nsigma,sigma,irrepBK,nmo,mosym,nsigmaH,&
       Hinfo_dim)

    use constants
    use detfuncs
    use stringhash
    
    implicit none

    ! Unique sigma strings
    integer(is), intent(in)  :: n_int,nsigma
    integer(ib), intent(in)  :: sigma(n_int,nsigma)

    ! Irrep generatated by the product of bra and ket wave functions
    integer(ib), intent(in)  :: irrepBK

    ! Irreps generated by the ket MOs
    integer(is), intent(in)  :: nmo
    integer(ib), intent(in)  :: mosym(nmo)
    
    ! Number of unique sigma-hole strings
    integer(is), intent(out) :: nsigmaH

    ! Number of (hole index, parent string, phase) tuples
    ! needed to characterise the sigma-hole strings
    integer(is), intent(out) :: Hinfo_dim
    
    ! Hash table
    type(shtbl)              :: h
    integer(is)              :: initial_size

    ! Hole strings
    integer(ib)              :: key(n_int)
    
    ! Occpied MOs
    integer(is)              :: nocc
    integer(is), allocatable :: occ(:)
    
    ! Everything else
    integer(is)              :: i,j
    integer(is)              :: n_ap
    integer(is), allocatable :: ap(:)

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(occ(nmo))
    allocate(ap(nmo))
    
!----------------------------------------------------------------------
! Initialise the hash table
!----------------------------------------------------------------------
    initial_size=nsigma
    call h%initialise_table(n_int,initial_size)

!----------------------------------------------------------------------
! Determine the number of unique sigma-hole strings
!----------------------------------------------------------------------
    Hinfo_dim=0

    ! Loop over unique sigma strings
    do i=1,nsigma

       ! Get the list of occupied MOs
       call mo_occ_string(n_int,sigma(:,i),nmo,nocc,occ)

       ! Reduce the list of MOs to those of symmetry
       ! irrepB \otimes irrepK
       n_ap=0
       do j=1,nocc
          if (mosym(occ(j)) == irrepBK) then
             n_ap=n_ap+1
             ap(n_ap)=occ(j)
          endif
       enddo

       ! Generate the sigma-hole strings and insert into the hash
       ! table
       do j=1,n_ap

          ! Update the no. (hole index, parent string, phase) tuples
          Hinfo_dim=Hinfo_dim+3
          
          ! Key: sigma-hole string
          key=annihilate_electron_string(n_int,sigma(:,i),&
               ap(j))

          ! Insert the (key, values) pair
          call h%insert_key(key)
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! The number of unique sigma-hole strings is the number of keys
! stored in the hash table
!----------------------------------------------------------------------
    nsigmaH=h%n_keys_stored
    
    return
    
  end subroutine get_nsigmaH

!######################################################################
! get_hole_strings: returns the unique sigma-hole strings along with
!                   the generating annihilation operator indices,
!                   parent sigma string indices and phase factors
!######################################################################
  subroutine get_hole_strings(n_int,nsigma,sigma,irrepBK,nmo,mosym,&
       nsigmaH,sigmaH,Hinfo_dim,Hinfo)

    use constants
    use detfuncs
    use stringhash
    
    implicit none

    ! Unique sigma strings
    integer(is), intent(in)  :: n_int,nsigma
    integer(ib), intent(in)  :: sigma(n_int,nsigma)

    ! Irrep generatated by the product of bra and ket wave functions
    integer(ib), intent(in)  :: irrepBK

    ! Irreps generated by the ket MOs
    integer(is), intent(in)  :: nmo
    integer(ib), intent(in)  :: mosym(nmo)
    
    ! Unique sigma-hole strings
    integer(is), intent(in)  :: nsigmaH
    integer(ib), intent(out) :: sigmaH(n_int,nsigmaH)
    
    ! (hole index, parent string, phase) tuples
    ! needed to characterise the sigma-hole strings
    integer(is), intent(in)  :: Hinfo_dim
    integer(is), intent(out) :: Hinfo(3,Hinfo_dim)
    
    ! Number of sigma strings generated by each sigma-hole string
    integer(is), allocatable :: ngen(:)

    ! Hash table
    type(shtbl)              :: h
    integer(is)              :: initial_size

    ! Hole strings
    integer(ib)              :: key(n_int)
    integer(is)              :: values(2)
    
    ! Occpied MOs
    integer(is)              :: nocc
    integer(is), allocatable :: occ(:)
    
    ! Everything else
    integer(is)              :: i,j
    integer(is)              :: n_ap
    integer(is), allocatable :: ap(:)
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(ngen(nsigmaH))
    ngen=0

    allocate(occ(nmo))

    allocate(ap(nmo))

!----------------------------------------------------------------------
! Initialise the hash table
!----------------------------------------------------------------------
    initial_size=nsigma
    call h%initialise_table(n_int,initial_size)

!----------------------------------------------------------------------
! Determine the unique sigma-hole strings along with the corresponding
! annihilation operator indices, phases and parent sigma-string
! indices
!----------------------------------------------------------------------
    ! Loop over unique sigma strings
    do i=1,nsigma

       ! Get the list of occupied MOs
       call mo_occ_string(n_int,sigma(:,i),nmo,nocc,occ)

       ! Reduce the list of MOs to those of symmetry
       ! irrepB \otimes irrepK
       n_ap=0
       do j=1,nocc
          if (mosym(occ(j)) == irrepBK) then
             n_ap=n_ap+1
             ap(n_ap)=occ(j)
          endif
       enddo

       ! Generate the sigma-hole strings and insert into the hash
       ! table
       do j=1,n_ap

          ! Key: sigma-hole string
          key=annihilate_electron_string(n_int,sigma(:,i),&
               ap(j))

          ! Annihilation operator index
          ! values(1)=ap(j)
          
          ! Parent sigma string index
          !values(2)=i

          ! Phase factor
          
          ! Insert the (key, values) pair
          call h%insert_key(key)
          
       enddo
       
    enddo
    
    return
    
  end subroutine get_hole_strings
    
!######################################################################
  
end module hole_strings
