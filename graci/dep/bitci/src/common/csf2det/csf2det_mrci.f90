!**********************************************************************
! Routines for the calculation of the determinant expansions of MRCI
! wave functions
!**********************************************************************
module csf2det

  implicit none

contains

!######################################################################
! det_trans: Handles the transformation from the CSF to determinant
!            bases; both the generation of the determinant bit strings
!            and the calculation of the eigenvectors in the
!            determinant basis
!
!            The MOs are reordered according to the input momap array
!######################################################################
  subroutine det_trans(cfg,momap,nroots,csfdim,detdim,vec_csf,&
       vec_det,det)

    use constants
    use bitglobal
    use conftype
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(in)  :: cfg

    ! MO mapping array
    integer(is), intent(in)  :: momap(nmo)
    
    ! Dimensions
    integer(is), intent(in)  :: nroots,csfdim,detdim

    ! Eigenvectors in the CSF and determinant bases
    real(dp), intent(in)     :: vec_csf(csfdim,nroots)
    real(dp), intent(out)    :: vec_det(detdim,nroots)

    ! Determinant bit strings
    integer(ib), intent(out) :: det(n_int,2,detdim)

    ! Doubly-occupied orbital phase factors
    integer(is), allocatable :: dphase(:)
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(dphase(detdim))
    dphase=0
    
!----------------------------------------------------------------------
! Get the determinant bit strings and the phases associated with the
! creation of the doubly-occupied orbitals
!----------------------------------------------------------------------
    call bitstrings_detbas(cfg,momap,detdim,det,dphase)
    
!----------------------------------------------------------------------
! Compute the determinant basis eigenvectors
!----------------------------------------------------------------------
    call eigenvectors_detbas(cfg,nroots,csfdim,detdim,vec_csf,vec_det,&
         dphase)

!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(dphase)
    
    return
    
  end subroutine det_trans
    
!######################################################################
! get_detdim: determines the number of determinants generated by a
!             given configuration basis
!######################################################################
  subroutine get_detdim(cfg,detdim)

    use constants
    use bitglobal
    use conftype
    use mrciutils

    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(in)  :: cfg

    ! Size of the determinant basis
    integer(is), intent(out) :: detdim

    ! Everyting else
    integer(is)              :: nopen,iconf

    !
    ! Initialisation
    !
    detdim=0

    !
    ! Reference space confs
    !
    do iconf=1,cfg%n0h
       nopen=sop_nopen(cfg%sop0h(:,:,iconf),cfg%n_int_I)
       detdim=detdim+ndets(nopen)
    enddo
    
    !
    ! 1I confs
    !
    do iconf=1,cfg%n1I
       nopen=sop_nopen(cfg%sop1I(:,:,iconf),n_int)
       detdim=detdim+ndets(nopen)       
    enddo

    !
    ! 2I confs
    !
    do iconf=1,cfg%n2I
       nopen=sop_nopen(cfg%sop2I(:,:,iconf),n_int)
       detdim=detdim+ndets(nopen)       
    enddo

    !
    ! 1E confs
    !
    do iconf=1,cfg%n1E
       nopen=sop_nopen(cfg%sop1E(:,:,iconf),n_int)
       detdim=detdim+ndets(nopen)       
    enddo

    !
    ! 2E confs
    !
    do iconf=1,cfg%n2E
       nopen=sop_nopen(cfg%sop2E(:,:,iconf),n_int)
       detdim=detdim+ndets(nopen)       
    enddo

    !
    ! 1I1E confs
    !
    do iconf=1,cfg%n1I1E
       nopen=sop_nopen(cfg%sop1I1E(:,:,iconf),n_int)
       detdim=detdim+ndets(nopen)       
    enddo

    return
    
  end subroutine get_detdim
    
!######################################################################
! eigenvectors_detbas: computes a set of eigenvectors in the
!                      determinant basis
!######################################################################
  subroutine eigenvectors_detbas(cfg,nroots,csfdim,detdim,vec_csf,&
       vec_det,dphase)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(in)  :: cfg

    ! Dimensions
    integer(is), intent(in)  :: nroots,csfdim,detdim

    ! Eigenvectors in the CSF and determinant bases
    real(dp), intent(in)     :: vec_csf(csfdim,nroots)
    real(dp), intent(out)    :: vec_det(detdim,nroots)

    ! Doubly-occupied orbital phase factors
    integer(is), intent(in)  :: dphase(detdim)
    
    ! CSF -> det transformation matrix
    real(dp), allocatable    :: transmat(:,:,:)
    
    ! Everything else
    integer(is)              :: i,n,nopen,ncsf,ndet,iconf
    integer(is)              :: icsf,jcsf,idet,jdet

!----------------------------------------------------------------------
! CSF -> det transformation matrix
!----------------------------------------------------------------------
    ! Allocate array
    allocate(transmat(maxdet,maxcsf,0:nomax))
    transmat=0.0d0

    ! Nopen = 0 case
    transmat(1,1,0)=1.0d0

    ! Nopen > 0 cases
    do n=1,nomax
       transmat(:,:,n)=transpose(csfcoe(:,:,n))
    enddo
    
!----------------------------------------------------------------------
! Initialisation
!----------------------------------------------------------------------
    ! Eigenvectors in the determinant basis
    vec_det=0.0d0

    ! CSF and determinant counters
    icsf=1
    jcsf=0
    idet=1
    jdet=0
    
!----------------------------------------------------------------------
! Ref space confs
!----------------------------------------------------------------------
    do iconf=1,cfg%n0h

       ! No. open shells
       nopen=sop_nopen(cfg%sop0h(:,:,iconf),cfg%n_int_I)
       
       ! No. CSFs & determinants
       ndet=ndets(nopen)
       ncsf=ncsfs(nopen)

       ! End points in the CSF and determinant basis eigenvectors
       jcsf=icsf+ncsf-1
       jdet=idet+ndet-1

       ! Determinant coefficicients
       do n=1,nroots
          vec_det(idet:jdet,n)=matmul(transmat(1:ndet,1:ncsf,nopen),&
               vec_csf(icsf:jcsf,n))
       enddo

       ! Start points in CSF and determinant basis eigenvectors for
       ! the next iteration
       icsf=jcsf+1
       idet=jdet+1
       
    enddo
    
!----------------------------------------------------------------------
! 1I confs
!----------------------------------------------------------------------
    do iconf=1,cfg%n1I

       ! No. open shells
       nopen=sop_nopen(cfg%sop1I(:,:,iconf),n_int)
       
       ! No. CSFs & determinants
       ndet=ndets(nopen)
       ncsf=ncsfs(nopen)

       ! End points in the CSF and determinant basis eigenvectors
       jcsf=icsf+ncsf-1
       jdet=idet+ndet-1

       ! Determinant coefficicients
       do n=1,nroots
          vec_det(idet:jdet,n)=matmul(transmat(1:ndet,1:ncsf,nopen),&
               vec_csf(icsf:jcsf,n))
       enddo
       
       ! Start points in CSF and determinant basis eigenvectors for
       ! the next iteration
       icsf=jcsf+1
       idet=jdet+1
       
    enddo

!----------------------------------------------------------------------
! 2I confs
!----------------------------------------------------------------------
    do iconf=1,cfg%n2I

       ! No. open shells
       nopen=sop_nopen(cfg%sop2I(:,:,iconf),n_int)
       
       ! No. CSFs & determinants
       ndet=ndets(nopen)
       ncsf=ncsfs(nopen)

       ! End points in the CSF and determinant basis eigenvectors
       jcsf=icsf+ncsf-1
       jdet=idet+ndet-1

       ! Determinant coefficicients
       do n=1,nroots
          vec_det(idet:jdet,n)=matmul(transmat(1:ndet,1:ncsf,nopen),&
               vec_csf(icsf:jcsf,n))
       enddo
       
       ! Start points in CSF and determinant basis eigenvectors for
       ! the next iteration
       icsf=jcsf+1
       idet=jdet+1
       
    enddo

!----------------------------------------------------------------------
! 1E confs
!----------------------------------------------------------------------
    do iconf=1,cfg%n1E

       ! No. open shells
       nopen=sop_nopen(cfg%sop1E(:,:,iconf),n_int)
       
       ! No. CSFs & determinants
       ndet=ndets(nopen)
       ncsf=ncsfs(nopen)

       ! End points in the CSF and determinant basis eigenvectors
       jcsf=icsf+ncsf-1
       jdet=idet+ndet-1

       ! Determinant coefficicients
       do n=1,nroots
          vec_det(idet:jdet,n)=matmul(transmat(1:ndet,1:ncsf,nopen),&
               vec_csf(icsf:jcsf,n))
       enddo
       
       ! Start points in CSF and determinant basis eigenvectors for
       ! the next iteration
       icsf=jcsf+1
       idet=jdet+1
       
    enddo

!----------------------------------------------------------------------
! 2E confs
!----------------------------------------------------------------------
    do iconf=1,cfg%n2E

       ! No. open shells
       nopen=sop_nopen(cfg%sop2E(:,:,iconf),n_int)
       
       ! No. CSFs & determinants
       ndet=ndets(nopen)
       ncsf=ncsfs(nopen)

       ! End points in the CSF and determinant basis eigenvectors
       jcsf=icsf+ncsf-1
       jdet=idet+ndet-1

       ! Determinant coefficicients
       do n=1,nroots
          vec_det(idet:jdet,n)=matmul(transmat(1:ndet,1:ncsf,nopen),&
               vec_csf(icsf:jcsf,n))
       enddo
       
       ! Start points in CSF and determinant basis eigenvectors for
       ! the next iteration
       icsf=jcsf+1
       idet=jdet+1
       
    enddo

!----------------------------------------------------------------------
! 1I1E confs
!----------------------------------------------------------------------
    do iconf=1,cfg%n1I1E

       ! No. open shells
       nopen=sop_nopen(cfg%sop1I1E(:,:,iconf),n_int)
       
       ! No. CSFs & determinants
       ndet=ndets(nopen)
       ncsf=ncsfs(nopen)

       ! End points in the CSF and determinant basis eigenvectors
       jcsf=icsf+ncsf-1
       jdet=idet+ndet-1

       ! Determinant coefficicients
       do n=1,nroots
          vec_det(idet:jdet,n)=matmul(transmat(1:ndet,1:ncsf,nopen),&
               vec_csf(icsf:jcsf,n))
       enddo
       
       ! Start points in CSF and determinant basis eigenvectors for
       ! the next iteration
       icsf=jcsf+1
       idet=jdet+1
       
    enddo

!----------------------------------------------------------------------
! Apply the phase factors associated with the creation of the doubly
! occupied orbitals
!----------------------------------------------------------------------
    do n=1,nroots
       do idet=1,detdim
          vec_det(idet,n)=vec_det(idet,n)*dphase(idet)
       enddo
    enddo
    
    return
    
  end subroutine eigenvectors_detbas
  
!######################################################################
! bitstrings_detbas: returns: (i) determinant basis bit strings given
!                    a set of MRCI configurations, and; (ii) the phase
!                    factors corresponding to the creation of the
!                    doubly-occupied orbitals
!
!                    the MOs are reordered according to the input
!                    momap array
!######################################################################
  subroutine bitstrings_detbas(cfg,momap,detdim,det,dphase)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(in)  :: cfg

    ! MO mapping array
    integer(is), intent(in)  :: momap(nmo)
    
    ! No. determinants
    integer(is), intent(in)  :: detdim

    ! Determinant bit strings
    integer(ib), intent(out) :: det(n_int,2,detdim)

    ! Doubly-occupied orbital phase factors
    integer(is), intent(out) :: dphase(detdim)

    ! SOPs in the output MO ordering
    integer(ib)              :: sop(n_int,2)
    
    ! Everything else
    integer(is)              :: nopen,ndet,iconf,idet,counter,n_int_I,k
    integer(is)              :: socc(nmo)

!----------------------------------------------------------------------
! Initialisation
!----------------------------------------------------------------------
    ! Determinant counter
    counter=0

    ! Determinant bit strings
    det=0_ib
    
!----------------------------------------------------------------------
! Ref space determinants
!----------------------------------------------------------------------
    n_int_I=cfg%n_int_I

    ! Loop over ref space confs
    do iconf=1,cfg%n0h
       
       ! Put the SOP into the output MO ordering
       sop=0_ib
       sop(1:n_int_I,:)=cfg%sop0h(:,:,iconf)
       call reorder_confs(nmo,momap,sop,1)

       ! Determine the singly-occupied MOs
       call sop_socc_list(sop,n_int,socc,nmo,nopen)
              
       ! No. determinants
       ndet=ndets(nopen)

       ! Loop over the determinants generated by this conf
       do idet=1,ndet

          ! Increment the determinant counter
          counter=counter+1

          ! Fill in the singly-occupied MOs
          call fill_socc_mos(nopen,socc,idet,det(:,:,counter))

          ! Get the doubly-occupied phase factors
          dphase(counter)=docc_phase(n_int_I,det(1:n_int_I,:,counter),&
               sop(1:n_int_I,:))
                    
          ! Fill in the doubly-occupied MOs
          do k=1,2
             det(1:n_int_I,k,counter)=ior(det(1:n_int_I,k,counter), &
                  sop(1:n_int_I,2))
          enddo

       enddo
       
    enddo
    
!----------------------------------------------------------------------
! 1I determinants
!----------------------------------------------------------------------
    ! Loop over 1I confs
    do iconf=1,cfg%n1I

       ! Put the SOP into the output MO ordering
       sop=cfg%sop1I(:,:,iconf)
       call reorder_confs(nmo,momap,sop,1)
       
       ! Determine the singly-occupied MOs
       call sop_socc_list(sop,n_int,socc,nmo,nopen)
       
       ! No. determinants
       ndet=ndets(nopen)

       ! Loop over the determinants generated by this conf
       do idet=1,ndet

          ! Increment the determinant counter
          counter=counter+1
          
          ! Fill in the singly-occupied MOs
          call fill_socc_mos(nopen,socc,idet,det(:,:,counter))

          ! Get the doubly-occupied phase factors
          dphase(counter)=docc_phase(n_int,det(:,:,counter),sop)

          ! Fill in the doubly-occupied MOs
          do k=1,2
             det(:,k,counter)=ior(det(:,k,counter),sop(:,2))
          enddo
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! 2I determinants
!----------------------------------------------------------------------
    ! Loop over 2I confs
    do iconf=1,cfg%n2I

       ! Put the SOP into the output MO ordering
       sop=cfg%sop2I(:,:,iconf)
       call reorder_confs(nmo,momap,sop,1)
       
       ! Determine the singly-occupied MOs
       call sop_socc_list(sop,n_int,socc,nmo,nopen)
       
       ! No. determinants
       ndet=ndets(nopen)

       ! Loop over the determinants generated by this conf
       do idet=1,ndet

          ! Increment the determinant counter
          counter=counter+1

          ! Fill in the singly-occupied MOs
          call fill_socc_mos(nopen,socc,idet,det(:,:,counter))

          ! Get the doubly-occupied phase factors
          dphase(counter)=docc_phase(n_int,det(:,:,counter),sop)

          ! Fill in the doubly-occupied MOs
          do k=1,2
             det(:,k,counter)=ior(det(:,k,counter),sop(:,2))
          enddo
          
       enddo
       
    enddo
    
!----------------------------------------------------------------------
! 1E determinants
!----------------------------------------------------------------------
    ! Loop over 1E confs
    do iconf=1,cfg%n1E

       ! Put the SOP into the output MO ordering
       sop=cfg%sop1E(:,:,iconf)
       call reorder_confs(nmo,momap,sop,1)
       
       ! Determine the singly-occupied MOs
       call sop_socc_list(sop,n_int,socc,nmo,nopen)
       
       ! No. determinants
       ndet=ndets(nopen)

       ! Loop over the determinants generated by this conf
       do idet=1,ndet

          ! Increment the determinant counter
          counter=counter+1
          
          ! Fill in the singly-occupied MOs
          call fill_socc_mos(nopen,socc,idet,det(:,:,counter))

          ! Get the doubly-occupied phase factors
          dphase(counter)=docc_phase(n_int,det(:,:,counter),sop)

          ! Fill in the doubly-occupied MOs
          do k=1,2
             det(:,k,counter)=ior(det(:,k,counter),sop(:,2))
          enddo
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! 2E determinants
!----------------------------------------------------------------------
    ! Loop over 2E confs
    do iconf=1,cfg%n2E

       ! Put the SOP into the output MO ordering
       sop=cfg%sop2E(:,:,iconf)
       call reorder_confs(nmo,momap,sop,1)
       
       ! Determine the singly-occupied MOs
       call sop_socc_list(sop,n_int,socc,nmo,nopen)
       
       ! No. determinants
       ndet=ndets(nopen)

       ! Loop over the determinants generated by this conf
       do idet=1,ndet

          ! Increment the determinant counter
          counter=counter+1
          
          ! Fill in the singly-occupied MOs
          call fill_socc_mos(nopen,socc,idet,det(:,:,counter))

          ! Get the doubly-occupied phase factors
          dphase(counter)=docc_phase(n_int,det(:,:,counter),sop)

          ! Fill in the doubly-occupied MOs
          do k=1,2
             det(:,k,counter)=ior(det(:,k,counter),sop(:,2))
          enddo
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! 1I1E determinants
!----------------------------------------------------------------------
    ! Loop over 1I1E confs
    do iconf=1,cfg%n1I1E

       ! Put the SOP into the output MO ordering
       sop=cfg%sop1I1E(:,:,iconf)
       call reorder_confs(nmo,momap,sop,1)
       
       ! Determine the singly-occupied MOs
       call sop_socc_list(sop,n_int,socc,nmo,nopen)
       
       ! No. determinants
       ndet=ndets(nopen)

       ! Loop over the determinants generated by this conf
       do idet=1,ndet

          ! Increment the determinant counter
          counter=counter+1
          
          ! Fill in the singly-occupied MOs
          call fill_socc_mos(nopen,socc,idet,det(:,:,counter))

          ! Get the doubly-occupied phase factors
          dphase(counter)=docc_phase(n_int,det(:,:,counter),sop)

          ! Fill in the doubly-occupied MOs
          do k=1,2
             det(:,k,counter)=ior(det(:,k,counter),sop(:,2))
          enddo
          
       enddo
       
    enddo

    return
    
  end subroutine bitstrings_detbas

!######################################################################
! fill_socc_mos: fills in the singly-occupied MOs in a determinant
!                bit string given the no. open shells, the list of
!                open shell MOs and the determinant index
!                idet \in {1,...,ndets(nopen)}
!######################################################################
  subroutine fill_socc_mos(nopen,socc,idet,det)

    use constants
    use bitglobal
    
    implicit none

    ! Open shells
    integer(is), intent(in)    :: nopen
    integer(is), intent(in)    :: socc(nmo)

    ! Determinant bit string
    integer(ib), intent(inout) :: det(n_int,2)

    ! Determinant index
    integer(is), intent(in)    :: idet

    ! Everything else
    integer(is)                :: i,i1,k

    ! Loop over the singly-occupied MOs
    do i1=1,nopen
       
       ! Block index
       k=(socc(i1)-1)/n_bits+1

       ! Position of the MO within the block
       i=socc(i1)-(k-1)*n_bits-1

       ! Add the electron
       if (btest(detvec(idet,nopen),i1-1)) then
          ! Alpha-spin electron
          det(k,1)=ibset(det(k,1),i)
       else
          ! Beta-spin electron
          det(k,2)=ibset(det(k,2),i)
       endif
       
    enddo
    
    return
    
  end subroutine fill_socc_mos

!######################################################################
! docc_phase: given a partial determinant bit string, detopen, with
!             only the open shell orbitals filled, returns the phase
!             factor arising from the creation of the doubly-occupied
!             orbtials (as specified by a SOP)
!######################################################################
  function docc_phase(ld,detopen,sop)

    use constants
    use bitglobal
    use detutils
    use mrciutils
    
    implicit none

    ! Function result
    integer(is)             :: docc_phase

    ! Partially filled determinant bit string
    integer(is), intent(in) :: ld
    integer(ib), intent(in) :: detopen(ld,2)

    ! SOP for the full conf/det
    integer(ib), intent(in) :: sop(ld,2)

    ! Number of open shells preceding each spin orbital
    integer(is)             :: nbefore(nmo,2)

    ! Doubly-occupied orbitals
    integer(is)             :: ndocc
    integer(is)             :: docc(nmo)
    
    ! Everything else
    integer(is)             :: i,imo
    integer(is)             :: alpha_phase,beta_phase
    
!----------------------------------------------------------------------
! Determine the number of open shells preceding each orbital in the
! alpha and beta strings
!----------------------------------------------------------------------
    call nbefore_det(ld,detopen,nbefore)

!----------------------------------------------------------------------
! Get the indices of the doubly-occupied orbitals
!----------------------------------------------------------------------
    call sop_docc_list(sop,ld,docc,nmo,ndocc)
    
!----------------------------------------------------------------------
! Phase factor for the creation of the alpha electrons
!----------------------------------------------------------------------
    alpha_phase=1
    do i=1,ndocc
       imo=docc(i)
       alpha_phase=alpha_phase*(-1)**(nbefore(imo,1)+i-1)
    enddo

!----------------------------------------------------------------------
! Phase factor for the creation of the beta electrons
!----------------------------------------------------------------------
    beta_phase=1
    do i=1,ndocc
       imo=docc(i)
       beta_phase=beta_phase*(-1)**(nbefore(imo,2)+i-1+nel_alpha)
    enddo
    
!----------------------------------------------------------------------
! Total phase factor
!----------------------------------------------------------------------
    docc_phase=alpha_phase*beta_phase
    
    return
    
  end function docc_phase
  
!######################################################################
  
end module csf2det
