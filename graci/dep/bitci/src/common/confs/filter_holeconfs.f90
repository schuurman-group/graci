module filter_confs

  implicit none
  
contains
  
!######################################################################
! filter_hole_confs: removes any hole configurations which do not
!                    generate any full configurations
!######################################################################
  subroutine filter_hole_confs(cfgM)

    use constants
    use bitglobal
    use conftype
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(inout) :: cfgM
    
!----------------------------------------------------------------------
! 1-hole configurations
!----------------------------------------------------------------------
    call filter_1hole_confs(cfgM)

!----------------------------------------------------------------------
! 2-hole configurations
!----------------------------------------------------------------------
    call filter_2hole_confs(cfgM)

    return
    
  end subroutine filter_hole_confs

!######################################################################
! filter_1hole_confs: removes any 1-hole configurations which do not
!                     generate any full configurations
!######################################################################
  subroutine filter_1hole_confs(cfgM)

    use constants
    use bitglobal
    use conftype
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(inout) :: cfgM

    ! Working arrays
    integer(ib), allocatable   :: conftmp(:,:,:)
    integer(is), allocatable   :: offtmp1I(:),offtmp1E(:)
    integer(is), allocatable   :: offtmp1h(:)
    integer(is), allocatable   :: a1htmp(:)
    integer(is), allocatable   :: ngen(:)
    
    ! Everything else
    integer(is)                :: n,iref,nok,counter,nlastI,nlastE,&
                                  countlastI,countlastE
    
!----------------------------------------------------------------------
! Determine the number of 1-hole configurations that generate full
! configurations
!----------------------------------------------------------------------
    nok=0
    
    ! Loop over 1-hole configurations
    do n=1,cfgM%n1h

       ! Does the current 1-hole configuration generate any 1I or
       ! 1E configurations?
       if (cfgM%off1I(n) /= cfgM%off1I(n+1) &
            .or. cfgM%off1E(n) /= cfgM%off1E(n+1)) nok=nok+1

    enddo
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(conftmp(cfgM%n_int_I,2,nok))
    conftmp=0_ib

    allocate(offtmp1I(nok+1))
    offtmp1I=0
    
    allocate(offtmp1E(nok+1))
    offtmp1E=0

    allocate(a1htmp(nok))
    a1htmp=0
    
    allocate(ngen(cfgM%nR))
    ngen=0

!----------------------------------------------------------------------
! Re-fill the off1h array
!----------------------------------------------------------------------
    ! Loop over reference configurations
    do iref=1,cfgM%nR

       ! Loop over the 1-hole configurations generated by the current
       ! reference configuration
       do n=cfgM%off1h(iref),cfgM%off1h(iref+1)-1

          ! Does the current 1-hole configuration generate any 1I
          ! or 1E configurations?
          if (cfgM%off1I(n) /= cfgM%off1I(n+1) &
               .or. cfgM%off1E(n) /= cfgM%off1E(n+1)) then

             ! Update the no. 1-hole configurations generated by
             ! the current reference configuration
             ngen(iref)=ngen(iref)+1
             
          endif
             
       enddo

    enddo

    ! Re-fill the off1h offset array
    cfgM%off1h(1)=1
    do n=2,cfgM%nR+1
       cfgM%off1h(n)=cfgM%off1h(n-1)+ngen(n-1)
    enddo
    
!----------------------------------------------------------------------
! Filter out the 1-hole configurations that don't generate any full
! configurations
!----------------------------------------------------------------------
    counter=0
    
    ! Loop over 1-hole configurations
    do n=1,cfgM%n1h

       ! Does the current 1-hole configuration generate any 1I or
       ! 1E configurations?
       if (cfgM%off1I(n) /= cfgM%off1I(n+1) &
            .or. cfgM%off1E(n) /= cfgM%off1E(n+1)) then

          ! Increment the OK 1-hole conf counter
          counter=counter+1

          ! Save the 1-hole conf
          conftmp(:,:,counter)=cfgM%conf1h(:,:,n)

          ! Save the 1I offset
          offtmp1I(counter)=cfgM%off1I(n)
          
          ! Save the 1E offset
          offtmp1E(counter)=cfgM%off1E(n)

          ! Save the annihilation operator index
          a1htmp(counter)=cfgM%a1h(n)
          
          ! End point of the 1-hole confs that generate
          ! 1I and 1E confs
          if (cfgM%off1I(n) /= cfgM%off1I(n+1)) then
             nlastI=n
             countlastI=counter
          endif
          if (cfgM%off1E(n) /= cfgM%off1E(n+1)) then
             nlastE=n
             countlastE=counter
          endif
             
       endif
       
    enddo

    ! Final offsets
    if (cfgM%n1I > 0) &
         offtmp1I(countlastI+1:nok+1)=cfgM%off1I(nlastI+1)

    if (cfgM%n1E > 0) &
         offtmp1E(countlastE+1:nok+1)=cfgM%off1E(nlastE+1)

!----------------------------------------------------------------------
! Re-allocate and fill in the 1-hole conf, offset and annhilation
! operator arrays
!----------------------------------------------------------------------
    cfgM%n1h=nok

    deallocate(cfgM%conf1h)
    deallocate(cfgM%off1I)
    deallocate(cfgM%off1E)
    deallocate(cfgM%a1h)
    
    allocate(cfgM%conf1h(cfgM%n_int_I,2,nok))
    allocate(cfgM%off1I(nok+1))
    allocate(cfgM%off1E(nok+1))
    allocate(cfgM%a1h(nok))
    
    cfgM%conf1h=conftmp
    cfgM%off1I=offtmp1I
    cfgM%off1E=offtmp1E
    cfgM%a1h=a1htmp

!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(conftmp)
    deallocate(offtmp1I)
    deallocate(offtmp1E)
    deallocate(a1htmp)
    deallocate(ngen)
    
    return
    
  end subroutine filter_1hole_confs
    
!######################################################################
! filter_2hole_confs: removes any 2-hole configurations which do not
!                     generate any full configurations
!######################################################################
  subroutine filter_2hole_confs(cfgM)

    use constants
    use bitglobal
    use conftype
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(inout) :: cfgM

    ! Working arrays
    integer(ib), allocatable   :: conftmp(:,:,:)
    integer(is), allocatable   :: offtmp2I(:),offtmp2E(:),&
                                  offtmp1I1E(:)
    integer(is), allocatable   :: a2htmp(:,:)
    integer(is), allocatable   :: ngen(:)
    
    ! Everything else
    integer(is)                :: n,iref,nok,counter,nlast2I,nlast2E,&
                                  nlast1I1E,countlast2I,countlast2E,&
                                  countlast1I1E
    
!----------------------------------------------------------------------
! Determine the number of 2-hole configurations that generate full
! configurations
!----------------------------------------------------------------------
    nok=0

    ! Loop over 2-hole configurations
    do n=1,cfgM%n2h

       ! Does the current 2-hole configuration generate any 2I, 2E
       ! or 1I1E configurations?
       if (cfgM%off2I(n) /= cfgM%off2I(n+1) &
            .or. cfgM%off2E(n) /= cfgM%off2E(n+1) &
            .or. cfgM%off1I1E(n) /= cfgM%off1I1E(n+1)) nok=nok+1
       
    enddo

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(conftmp(cfgM%n_int_I,2,nok))
    conftmp=0_ib

    allocate(offtmp2I(nok+1))
    offtmp2I=0
    
    allocate(offtmp2E(nok+1))
    offtmp2E=0

    allocate(offtmp1I1E(nok+1))
    offtmp1I1E=0

    allocate(a2htmp(2,nok))
    a2htmp=0
    
    allocate(ngen(cfgM%nR))
    ngen=0

!----------------------------------------------------------------------
! Re-fill the off2h array
!----------------------------------------------------------------------
    ! Loop over reference configurations
    do iref=1,cfgM%nR

       ! Loop over the 2-hole configurations generated by the current
       ! reference configuration
       do n=cfgM%off2h(iref),cfgM%off2h(iref+1)-1

          ! Does the current 2-hole configuration generate any 2I, 2E
          ! or 1I1E configurations?
          if (cfgM%off2I(n) /= cfgM%off2I(n+1) &
               .or. cfgM%off2E(n) /= cfgM%off2E(n+1) &
               .or. cfgM%off1I1E(n) /= cfgM%off1I1E(n+1)) then

             ! Update the no. 2-hole configurations generated by
             ! the current reference configuration
             ngen(iref)=ngen(iref)+1
             
          endif
             
       enddo

    enddo

    ! Re-fill the off2h offset array
    cfgM%off2h(1)=1
    do n=2,cfgM%nR+1
       cfgM%off2h(n)=cfgM%off2h(n-1)+ngen(n-1)
    enddo
    
!----------------------------------------------------------------------
! Filter out the 2-hole configurations that don't generate any full
! configurations
!----------------------------------------------------------------------
    counter=0

    ! Loop over 2-hole configurations
    do n=1,cfgM%n2h

       ! Does the current 2-hole configuration generate any 2I, 2E
       ! or 1I1E configurations?
       if (cfgM%off2I(n) /= cfgM%off2I(n+1) &
            .or. cfgM%off2E(n) /= cfgM%off2E(n+1) &
            .or. cfgM%off1I1E(n) /= cfgM%off1I1E(n+1)) then

          ! Increment the OK 2-hole conf counter
          counter=counter+1

          ! Save the 2-hole conf
          conftmp(:,:,counter)=cfgM%conf2h(:,:,n)

          ! Save the 2I offset
          offtmp2I(counter)=cfgM%off2I(n)
          
          ! Save the 2E offset
          offtmp2E(counter)=cfgM%off2E(n)

          ! Save the 1I1E offset
          offtmp1I1E(counter)=cfgM%off1I1E(n)

          ! Save the annihilation operator indices
          a2htmp(:,counter)=cfgM%a2h(:,n)
          
          ! End point of the 2-hole confs that generate
          ! 2I, 2E and 1I1E confs
          if (cfgM%off2I(n) /= cfgM%off2I(n+1)) then
             nlast2I=n
             countlast2I=counter
          endif
          if (cfgM%off2E(n) /= cfgM%off2E(n+1)) then
             nlast2E=n
             countlast2E=counter
          endif
          if (cfgM%off1I1E(n) /= cfgM%off1I1E(n+1)) then
             nlast1I1E=n
             countlast1I1E=counter
          endif
          
       endif

    enddo

    ! Final offsets
    if (cfgM%n2I > 0) &
         offtmp2I(countlast2I+1:nok+1)=cfgM%off2I(nlast2I+1)

    if (cfgM%n2E > 0) &
         offtmp2E(countlast2E+1:nok+1)=cfgM%off2E(nlast2E+1)

    if (cfgM%n1I1E > 0) &
         offtmp1I1E(countlast1I1E+1:nok+1)=cfgM%off1I1E(nlast1I1E+1)
    
!----------------------------------------------------------------------
! Re-allocate and fill in the 2-hole conf and offset arrays
!----------------------------------------------------------------------
    cfgM%n2h=nok

    deallocate(cfgM%conf2h)
    deallocate(cfgM%off2I)
    deallocate(cfgM%off2E)
    deallocate(cfgM%off1I1E)
    deallocate(cfgM%a2h)

    allocate(cfgM%conf2h(cfgM%n_int_I,2,nok))
    allocate(cfgM%off2I(nok+1))
    allocate(cfgM%off2E(nok+1))
    allocate(cfgM%off1I1E(nok+1))
    allocate(cfgM%a2h(2,nok))
    
    cfgM%conf2h=conftmp
    cfgM%off2I=offtmp2I
    cfgM%off2E=offtmp2E
    cfgM%off1I1E=offtmp1I1E
    cfgM%a2h=a2htmp
    
!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(conftmp)
    deallocate(offtmp2I)
    deallocate(offtmp2E)
    deallocate(offtmp1I1E)
    deallocate(a2htmp)
    deallocate(ngen)
    
    return

  end subroutine filter_2hole_confs
  
!######################################################################

end module filter_confs
