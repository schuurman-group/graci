!**********************************************************************
! Routines for sorting arrays of determinants
!**********************************************************************
! The subroutine det_sort_sym simply arranges the determinants in
! order of in increasing irrep index.
!**********************************************************************
! The subroutine det_sort_spin is of central importance: by sorting
! the set of determinants by either their alpha strings, we can
! achieve an O(N^1.5) scaling of the sigma-vector code with the number
! of determinants.
!**********************************************************************
! Note that det_sort_sym must be called *before* det_sort_spin.
!**********************************************************************

module detsort

contains

!######################################################################
! det_sort_sym: Sorts an array of determinants by their irreps
!######################################################################
  subroutine det_sort_sym(d,ndet,nsym)

    use constants
    use bitglobal
    use detutils
    
    implicit none
    
    integer(is), intent(in)     :: ndet
    integer(ib), intent(inout)  :: d(n_int,2,ndet)
    integer(is), intent(out)    :: nsym(0:nirrep-1)
    integer(ib), allocatable    :: dsorted(:,:,:)
    integer(is), allocatable    :: isym(:)
    integer(is)                 :: i,k,indx
    integer(is), allocatable    :: ioff(:),counter(:)
    integer(is)                 :: sum
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(dsorted(n_int,2,ndet))
    allocate(isym(ndet))
    allocate(ioff(0:nirrep-1))
    allocate(counter(0:nirrep-1))
  
!----------------------------------------------------------------------
! Determine the irreps generated by each determinant
!----------------------------------------------------------------------
    do k=1,ndet
       isym(k)=det_sym(d(:,:,k))
    enddo

!----------------------------------------------------------------------
! Sort the determinants by symmetry
!----------------------------------------------------------------------
    ! Determine the number of determines per irrep
    nsym=0
    do k=1,ndet
       nsym(isym(k))=nsym(isym(k))+1
    enddo

    ! Offsets
    ioff=0
    sum=0
    do i=0,nirrep-1
       ioff(i)=sum
       sum=sum+nsym(i)
    enddo
    
    ! Fill in the irrep-sorted determinant array
    counter=0
    do k=1,ndet
       counter(isym(k))=counter(isym(k))+1
       indx=ioff(isym(k))+counter(isym(k))
       dsorted(:,:,indx)=d(:,:,k)
    enddo

    ! Re-write d
    d=dsorted

!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(dsorted)
    deallocate(isym)
    deallocate(ioff)
    deallocate(counter)
    
    return
    
  end subroutine det_sort_sym
  
!######################################################################
! det_sort_spin: Sorts an array of determinants by their alpha or beta
!                strings. Uses radix sort.
!######################################################################
  subroutine det_sort_spin(d,imap,ndet,ispin)
    
    use constants
    use bitglobal
    
    implicit none

    integer(is), intent(in)    :: ndet,ispin
    integer(ib), intent(inout) :: d(n_int,2,ndet)
    integer(is), intent(inout) :: imap(ndet)
    integer(ib), parameter     :: radix=64
    integer(is)                :: i,j
    integer(is)                :: digits
    integer(ib)                :: kmax
    
!----------------------------------------------------------------------
! Initialise the mapping array
!----------------------------------------------------------------------
    do i=1,ndet
       imap(i)=i
    enddo
    
!----------------------------------------------------------------------
! Do the sorting: outer loop over the n_int integers used to represent
! each alpha string, inner loop over the digits of each of these
! integers
!----------------------------------------------------------------------
    ! Loop backwards over the n_int integers
    do i=n_int,1,-1

       ! Largest number in position i across all alpha strings
       kmax=maxval(d(i,1,:))
       
       ! Cycle if the current block of alpha strings is unoccupied
       ! across all determinants
       if (kmax == 0_ib) cycle
       
       ! Number of digits needed to represent k in base radix
       digits=floor(log(dble(kmax))/log(dble(radix))+1)
       
       ! Loop over digits in the current set of alpha string integers
       do j=0,digits-1

          ! Counting sort
          call counting_sort(d,j,i,radix,ispin,ndet,imap)
          
       enddo
       
    enddo

    return
    
  end subroutine det_sort_spin

!######################################################################

  subroutine counting_sort(dA,idigit,iint,radix,ispin,ndet,imapA)

    use constants
    use bitglobal
    
    implicit none

    integer(is), intent(in)    :: idigit,iint,ispin,ndet
    integer(ib), intent(in)    :: radix
    integer(ib), intent(inout) :: dA(n_int,2,ndet)
    integer(is), intent(inout) :: imapA(ndet)
    integer(ib), allocatable   :: dB(:,:,:)
    integer(is), allocatable   :: C(:)
    integer(is), allocatable   :: imapB(:)
    integer(is)                :: i,k

!----------------------------------------------------------------------
! Allocate and initialise the array to hold the sorted elements of the
! determinant array
!----------------------------------------------------------------------
    allocate(dB(n_int,2,ndet))
    dB=0_ib

!----------------------------------------------------------------------
! Allocate and initialise the array to hold the sorted elements of the
! mapping array
!----------------------------------------------------------------------
    allocate(imapB(ndet))
    imapB=0
    
!----------------------------------------------------------------------
! Allocate and initialise the counting array
!----------------------------------------------------------------------
    allocate(C(0:radix-1))
    C=0

!----------------------------------------------------------------------
! Count the number of occurences of each digit
!----------------------------------------------------------------------
    do i=1,ndet
       k=iand(ishft(dA(iint,ispin,i),-6_ib*idigit),radix-1_ib)
       C(k)=C(k)+1
    enddo

!----------------------------------------------------------------------
! Alter C s.t. C(i) is equal to the number of occurences of digits
! <=i
!----------------------------------------------------------------------
    do i=1,radix-1
       C(i)=C(i)+C(i-1)
    enddo

!----------------------------------------------------------------------
! Fill in the sorted array dB and the mapping array imapB
!----------------------------------------------------------------------
    ! Loop backwards through dA
    do i=ndet,1,-1
       k=iand(ishft(dA(iint,ispin,i),-6_ib*idigit),radix-1_ib)
       C(k)=C(k)-1
       dB(:,:,C(k)+1)=dA(:,:,i)
       imapB(C(k)+1)=imapA(i)
    enddo

!----------------------------------------------------------------------
! Overwrite the input array and mapping array with the sorted values
!----------------------------------------------------------------------
    dA=dB
    imapA=imapB
    
!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(dB)
    deallocate(imapB)
    
    return
    
  end subroutine counting_sort

!######################################################################
! get_offsets: For an array of determinant d that has been pre-sorted
!              by irrep and put into ispin-major order, computes the
!              starting point in each symmetry block of each unique
!              alpha/beta string.
!
!              On input, offset is not yet allocated.
!
!              On output, offset(n,i) gives the starting point in d of
!              n'th unique alpha/beta string for the i'th irrep.
!######################################################################
  subroutine get_offsets(offset,offdim,nunique,d,ndet,nsym,ispin)

    use constants
    use bitglobal
    
    implicit none

    integer(is), intent(in)               :: ndet,ispin
    integer(is), allocatable, intent(out) :: offset(:,:)
    integer(is), intent(out)              :: offdim
    integer(is), intent(inout)            :: nunique(0:nirrep-1)
    integer(is), intent(in)               :: nsym(0:nirrep-1)
    integer(ib), intent(in)               :: d(n_int,2,ndet)
    integer(is)                           :: i,i1,i2,j,k,counter
    integer(ib)                           :: last(n_int)
    logical                               :: same
    
!----------------------------------------------------------------------
! Determine the number of unique alpha/beta strings for each irrep
!----------------------------------------------------------------------
    ! Initialisation
    nunique=0

    ! Loop over irreps
    i2=0
    do i=0,nirrep-1

       ! Cycle if there are no determinants of the current symmetry
       if (nsym(i)==0) cycle

       ! Loop over determinants in the current symmetry block
       i1=i2+1
       i2=i2+nsym(i)
       last=d(:,ispin,i1)
       nunique(i)=1
       do j=i1+1,i2
          same=.true.
          do k=1,n_int
             if (d(k,ispin,j)/=last(k)) then
                same=.false.
                exit
             endif
          enddo
          if (.not.same) then
             nunique(i)=nunique(i)+1
             last=d(:,ispin,j)
          endif

       enddo

    enddo

!----------------------------------------------------------------------
! Allocate the offsets array
!----------------------------------------------------------------------
    offdim=maxval(nunique)+1
    allocate(offset(offdim,0:nirrep-1))

!----------------------------------------------------------------------
! Fill in the offsets array
!----------------------------------------------------------------------
    ! Initialisation
    offset=0

    ! Loop over irreps
    i2=0
    do i=0,nirrep-1

       ! Cycle if there are no determinants of the current symmetry
       if (nsym(i)==0) cycle
       
       ! Loop over determinants in the current symmetry block
       i1=i2+1
       i2=i2+nsym(i)
       last=d(:,ispin,i1)
       counter=1
       offset(counter,i)=i1
       do j=i1+1,i2
          same=.true.
          do k=1,n_int
             if (d(k,ispin,j)/=last(k)) then
                same=.false.
                exit
             endif
          enddo
          if (.not.same) then
             counter=counter+1
             offset(counter,i)=j
             last=d(:,ispin,j)
          endif
       enddo

       ! Last offset element
       offset(nunique(i)+1,i)=i2+1
       
    enddo
    
    return
    
  end subroutine get_offsets
  
!######################################################################
! det_sort_all: Performs all the sorting required to use a set of
!               determinants with the Hamiltonian build routines
!######################################################################
  subroutine det_sort_all(da,db,ndet,nsym,mapab,offset_a,offset_b,&
       offdim_a,offdim_b,nunique_a,nunique_b)

    use constants
    use bitglobal
    
    implicit none

    integer(is), intent(in)               :: ndet
    integer(is), intent(out)              :: offdim_a,offdim_b
    integer(ib), intent(inout)            :: da(n_int,2,ndet)
    integer(ib), intent(inout)            :: db(n_int,2,ndet)
    integer(is), intent(out)              :: nsym(0:nirrep-1)
    integer(is), intent(out)              :: mapab(ndet)
    integer(is), allocatable, intent(out) :: offset_a(:,:),offset_b(:,:)
    integer(is), intent(out)              :: nunique_a(0:nirrep-1)
    integer(is), intent(out)              :: nunique_b(0:nirrep-1)
    
    integer(is)                           :: i,i1,i2,n,ispin

!----------------------------------------------------------------------
! Sort the determinants by symmetry
!----------------------------------------------------------------------
    call det_sort_sym(da,ndet,nsym)
    
!----------------------------------------------------------------------
! Sort the determinants by their alpha string
!----------------------------------------------------------------------
    ! Loop over irreps
    i2=0
    do i=0,nirrep-1
       
       ! Cycle if there are no determinants of the current symmetry
       if (nsym(i)==0) cycle
       
       ! Start and end of the current irrep block
       i1=i2+1
       i2=i2+nsym(i)
       n=i2-i1+1
       
       ! Sort the determinants in the current irrep block by their
       ! alpha strings. Note that mapab is just being passed as a
       ! dummy array here and will be filled in properly when we
       ! sort by beta string.
       call det_sort_spin(da(:,:,i1:i2),mapab(i1:i2),n,ialpha)
     
    enddo
    
!----------------------------------------------------------------------
! Determine the starting points of each unique alpha string in the
! alpha-major sorted determinant array
!----------------------------------------------------------------------
    call get_offsets(offset_a,offdim_a,nunique_a,da,ndet,nsym,ialpha)

!----------------------------------------------------------------------
! Sort the determinants by their beta string
!----------------------------------------------------------------------
    ! Initialise to the alpha major-ordered array of determinants
    ! (important as we need to get the mapping between the alpha
    ! and beta major-orderd arrays)
    db=da
    
    ! Loop over irreps
    i2=0
    do i=0,nirrep-1
       
       ! Cycle if there are no determinants of the current symmetry
       if (nsym(i)==0) cycle
       
       ! Start and end of the current irrep block
       i1=i2+1
       i2=i2+nsym(i)
       n=i2-i1+1
       
       ! Sort the determinants in the current irrep block by their
       ! beta strings
       call det_sort_spin(db(:,:,i1:i2),mapab(i1:i2),n,ibeta)

       ! Add sum of the numbers of determinants in the previous
       ! irrep blocks to the mapping array to get the correct
       ! values
       mapab(i1:i2)=mapab(i1:i2)+i1-1
              
    enddo

!----------------------------------------------------------------------
! Determine the starting points of each unique beta string in the
! beta-major sorted determinant array
!----------------------------------------------------------------------
    call get_offsets(offset_b,offdim_b,nunique_b,db,ndet,nsym,ibeta)
    
    return
    
  end subroutine det_sort_all
    
!######################################################################
  
end module detsort
