module bitutils

  implicit none

contains

!######################################################################
! n_alpha_electrons: given a determinant d, returns the number of
!                    alpha electrons
!######################################################################
  function n_alpha_electrons(d) result(nalpha)

    use constants
    use bitglobal
    
    implicit none

    integer(is)             :: nalpha
    integer(ib), intent(in) :: d(n_int,2)
    integer(is)             :: k

    nalpha=0
    do k=1,n_int
       nalpha=nalpha+popcnt(d(k,1))
    enddo
    
    return
    
  end function n_alpha_electrons

!######################################################################
! n_beta_electrons: given a determinant d, returns the number of
!                   beta electrons
!######################################################################
  function n_beta_electrons(d) result(nbeta)

    use constants
    use bitglobal
    
    implicit none

    integer(is)             :: nbeta
    integer(ib), intent(in) :: d(n_int,2)
    integer(is)             :: k

    nbeta=0
    do k=1,n_int
       nbeta=nbeta+popcnt(d(k,2))
    enddo
       
    return
    
  end function n_beta_electrons

!######################################################################
! homo_index: given a determinant d, returns the index of the HOMO
!######################################################################
  function homo_index(d) result(ihomo)

    use constants
    use bitglobal
    
    implicit none

    integer(ib), intent(in) :: d(n_int,2)
    integer(is)             :: ihomo
    integer(is)             :: k,ispin,n,msb
    integer(is)             :: ihighest(2)
        
    !
    ! Get the index of the HOMO
    !
    ihighest=0
    do ispin=1,2
       do k=1,n_int
          if (popcnt(d(k,ispin)).eq.0) cycle
          msb=most_significant_bit(d(k,ispin))
          ihighest(ispin)=msb+(k-1)*64
       enddo
    enddo
    ihomo=maxval(ihighest)

    return

  end function homo_index
    
!######################################################################
! get_sop: given a determinant d, computes the associated spatial
!          occupation pattern (SOP)
!######################################################################
  subroutine get_sop(d,sop)

    use constants
    use bitglobal
    
    implicit none

    integer(ib), intent(in)    :: d(n_int,2)   ! Input determinant
    integer(ib), intent(inout) :: sop(n_int,2) ! Output SOP
    integer(is)                :: k
  
    ! Loop over elements of the determinant array
    do k=1,n_int
     
       ! Encoding of the singly-occupied orbitals
       sop(k,1)=ieor(d(k,1),d(k,2))
       
       ! Encoding of the doubly-occupied orbitals
       sop(k,2)=iand(d(k,1),d(k,2))
       
    enddo
  
    return
  
  end subroutine get_sop

!######################################################################
! ndet_tot: for a given SOP, returns the total number of determinants
!           that can be generated from it
!######################################################################
  function ndet_tot(sop,nalpha)

    use constants
    use bitglobal
    use math
    
    implicit none

    integer(is) :: ndet_tot
    
    integer(ib), intent(in) :: sop(n_int,2) ! Input SOP
    integer(is), intent(in) :: nalpha       ! No. alpha electrons
    integer(is)             :: k,l
    integer(is)             :: nopen,ndocc,nua

    !
    ! Number of open shell spatial orbitals
    !
    nopen=0
    do k=1,n_int
       nopen=nopen+popcnt(sop(k,1))
    enddo

    !
    ! Number of doubly-occupied spatial orbitals
    !
    ndocc=0
    do k=1,n_int
       ndocc=ndocc+popcnt(sop(k,2))
    enddo

    !
    ! Number of unpaired alpha electrons
    !
    nua=nalpha-ndocc

    !
    ! Total number of determinants generated by the SOP
    !
    ndet_tot=int(bico(nopen,nua))
    
    return
    
  end function ndet_tot
    
!######################################################################
! swap_bits: given a bit string b, swaps the bits at positions p and q
!            *note that we are assuming that the two bits have
!             different values here*
!######################################################################
  subroutine swap_bits(b,p,q)

    use constants
    
    implicit none

    integer(ib), intent(inout) :: b
    integer(is), intent(in)    :: p,q
    integer(ib)                :: t,u

    u=ishft(1_ib,p)
    t=ieor(u,b)
    u=ishft(1_ib,q)
    b=ieor(u,t)
    
    return
    
  end subroutine swap_bits
    
!######################################################################
! get_occ: given a determinant, d, returns the indices of the occupied
!          alpha and beta orbitals
!######################################################################
  subroutine get_occ(d,occ)

    use constants
    use bitglobal
    
    implicit none

    integer(ib), intent(in)    :: d(n_int,2)
    integer(is), intent(inout) :: occ(nmo,2)
    integer(is)                :: ic,k,ipos,ispin
    integer(ib)                :: h
    
    !
    ! Get the indices of the occupied alpha and beta orbitals
    !
    ! Loop over alpha and beta spins
    do ispin=1,2

       ! Initialise the orbital counter
       ic=1

       ! Loop over bit string blocks for the current spin
       do k=1,n_int

          ! Initialise the work array
          h=d(k,ispin)

          ! Get the occupied orbital indices for this block
          do while (h.ne.0_ib)

             ! Number of trailing zeros left in h
             ipos=trailz(h)

             ! Index of the next occupied orbital
             occ(ic,ispin)=1+ipos+(k-1)*64

             ! Clear the bits up to the occupied orbital in h
             h=ibclr(h,ipos)

             ! Increment the orbital counter
             ic=ic+1
             
          enddo
          
       enddo

    enddo
    
    return
    
  end subroutine get_occ

!######################################################################
! get_unocc: given a determinant, d, returns the indices of the
!            unoccupied alpha and beta orbitals
!######################################################################
  subroutine get_unocc(d,unocc)

    use constants
    use bitglobal
    
    implicit none

    integer(ib), intent(in)    :: d(n_int,2)
    integer(is), intent(inout) :: unocc(nmo,2)
    integer(is)                :: ic,k,ipos,ispin,imo
    integer(ib)                :: h,u
    
    !
    ! Get the indices of the unoccupied alpha and beta orbitals
    !
    ! Loop over alpha and beta spins
    do ispin=1,2
       
       ! Initialise the orbital counter
       ic=1

       ! Loop over bit string blocks for the current spin
       do k=1,n_int

          ! Swap all bit values
          u=not(d(k,ispin))
          
          ! Initialise the work array
          h=u

          ! Get the unoccupied orbital indices for this block
          do while (h.ne.0_ib)

             ! Number of trailing zeros left in h
             ipos=trailz(h)

             ! Exit if we have reached the end of the MOs in the basis
             ! This will happen when nmo/64 is not an integer
             imo=1+ipos+(k-1)*64
             if (imo.gt.nmo) exit
             
             ! Index of the next occupied orbital
             unocc(ic,ispin)=imo
             
             ! Clear the bits up to the occupied orbital in h
             h=ibclr(h,ipos)

             ! Increment the orbital counter
             ic=ic+1

          enddo

       enddo

    enddo

    return
    
  end subroutine get_unocc

!######################################################################
! get_permutations: for a bit string composed of n bits set to 1 and m
!                   bits set to 0, computes all possible permutations
!----------------------------------------------------------------------
!                   Uses Anderson's algorithm:
!                   graphics.stanford.edu/~seander/bithacks.html
!----------------------------------------------------------------------
!                   Also see this paper by Anthony Scemama:
!                   https://arxiv.org/abs/1812.06902
!######################################################################
  subroutine get_permutations(n,m,v,vdim)

    use constants
    
    implicit none

    integer(is), intent(in)    :: n,m,vdim
    integer(ib), intent(inout) :: v(vdim)
    integer(is)                :: k
    integer(ib)                :: u,t,tp,tpp,lim

    !
    ! Special case: n=0
    !
    if (n==0) then
       v(1)=0_ib
       return
    endif
    
    !
    ! Initialise the permutation counter
    !
    k=1

    !
    ! Set the first permutation to 00...011...1
    !
    u=ishft(1_ib,n)-1_ib
    
    !
    ! Remaining permutations
    !
    lim=ishft(1_ib,n+m)
    do while(u.lt.lim)
       v(k)=u
       k=k+1
       t=ior(u,u-1_ib)
       tp=t+1_ib
       tpp=ishft((iand(not(t),tp)-1_ib),-(trailz(u)+1_ib))
       u=ior(tp,tpp)
    enddo
    
    return
    
  end subroutine get_permutations
  
!######################################################################
! most_significant_bit: returns the most significant bit in the
!                       64 bit integer i
!######################################################################
  function most_significant_bit(i) result(msb)

    use constants

    implicit none

    integer(ib), intent(in)  :: i
    integer(is)              :: msb
    integer(ib)              :: ii
    
    msb=0
    ii=i
    do while (ii.ne.0_ib)
       msb=msb+1
       ii=ishft(ii,-1)
    enddo

    return
    
  end function most_significant_bit

!######################################################################
! det_hash: hash of a determinant. Based on the boost hash_combine
!           algorithm but modified to work with 64-bit integers
!######################################################################
  function det_hash(det) result(hash)
    
    use constants
    use bitglobal
    
    implicit none

    integer(ib)             :: hash
    integer(ib), intent(in) :: det(n_int,2)
    integer                 :: i,k
    
    hash=0_ib
    do i=1,2
       do k=1,n_int
          hash=ieor(hash,det(k,i)+7046029254386353130_ib+ishft(hash,6)&
               +ishft(hash,-2))
       enddo
    enddo

    return
    
  end function det_hash
  
!######################################################################
  
end module bitutils
