!**********************************************************************
! Calculation of 1-RDMs using a simple double loop algorithm
!**********************************************************************
module rdm_double

  use constants
  
  implicit none

  ! Spin-coupling coefficients
  real(dp), allocatable, private :: scp(:,:)
  
contains
  
!######################################################################
! rdm_double_loop: Calculation of a set of 1-RDMs for a single irrep
!                  using the simple double loop algorithm
!######################################################################
  subroutine rdm_double_loop(confdim,csfdim,conf,sop,offset,nroots,&
       vec,rho,m2c)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use pattern_indices
    use bitstrings
    use iomod
    use timing
    
    implicit none

    ! No. confs and CSFs
    integer(is), intent(in) :: confdim,csfdim

    ! Confs, SOPs and CSF offsets
    integer(ib), intent(in) :: conf(n_int,2,confdim)
    integer(ib), intent(in) :: sop(n_int,2,confdim)
    integer(is), intent(in) :: offset(confdim+1)

    ! No. roots for which the RDMs will be computed
    integer(is), intent(in) :: nroots
    
    ! Eigenvectors
    real(dp), intent(in)    :: vec(csfdim,nroots)
    
    ! Density matrix
    real(dp), intent(out)   :: rho(nmo,nmo,nroots)

    ! MO mapping array
    integer(is), intent(in) :: m2c(nmo)
    
    ! MO classes
    integer(is)             :: socc(nmo),docc(nmo),unocc(nmo)
    integer(is)             :: nsocc,ndocc,nunocc

    ! Working arrays
    integer(ib)             :: bconf(n_int,2),bsop(n_int,2)
    integer(is), parameter  :: maxexci=1
    integer(is)             :: hlist(maxexci),plist(maxexci)
    integer(is)             :: nbefore(nmo)
    
    ! Everything else
    integer(is)             :: arrdim
    integer(is)             :: iconf,icsf,ibconf,ikconf,ibcsf,ikcsf
    integer(is)             :: bomega,komega,nexci
    integer(is)             :: knopen,bnopen,knsp,bnsp
    integer(is)             :: i,a,n,ista,imo
    integer(is)             :: n_int_I
    real(dp)                :: c2,trace,bcoe,kcoe,prod
    
    ! Timing variables
    real(dp)                :: tcpu_start,tcpu_end,twall_start,&
                               twall_end
    
!----------------------------------------------------------------------
! Start timing
!----------------------------------------------------------------------
    call get_times(twall_start,tcpu_start)  
    
!----------------------------------------------------------------------
! Allocate and initialise arrays
!----------------------------------------------------------------------
    rho=0.0d0

    arrdim=maxval(ncsfs(0:nomax))
    allocate(scp(arrdim,arrdim))
    scp=0.0d0

!----------------------------------------------------------------------
! On-diagonal elements
!----------------------------------------------------------------------
    ! Loop over configurations
    do iconf=1,confdim

       ! Get the lists of singly-occupied and doubly-occupied MOs
       call sop_socc_list(sop(:,:,iconf),n_int,socc,nmo,nsocc)
       call sop_docc_list(sop(:,:,iconf),n_int,docc,nmo,ndocc)

       ! Loop over roots
       do ista=1,nroots
          
          ! Loop over CSFs generated by this configuration
          do icsf=offset(iconf),offset(iconf+1)-1

             ! Coefficient squared
             c2=vec(icsf,ista)**2

             ! Singly-occupied MO contributions to the 1-RDM
             do i=1,nsocc
                imo=m2c(socc(i))
                rho(imo,imo,ista)=rho(imo,imo,ista)+c2
             enddo

             ! Doubly-occupied MO contributions to the 1-RDM
             do i=1,ndocc
                imo=m2c(docc(i))
                rho(imo,imo,ista)=rho(imo,imo,ista)+2.0d0*c2
             enddo
             
          enddo
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! Sanity check on the traces of the 1-RDMs
!----------------------------------------------------------------------
    ! Loop over roots
    do ista=1,nroots
       trace=0.0d0
       ! Loop over MOs
       do imo=1,nmo
          trace=trace+rho(imo,imo,ista)
       enddo
       ! Exit here if the trace of the 1-RDM does not equal the
       ! no. electrons
       if (abs(trace-nel) > 1e-10_dp) then
          errmsg='Incorrect Tr(rho) in rdm_mrci_diag'
          call error_control
       endif
    enddo
    
!----------------------------------------------------------------------
! Off-diagonal elements
!----------------------------------------------------------------------
    ! Loop over ket configurations
    do ikconf=1,confdim-1

       ! Number of open shells in the ket configuration
       knopen=sop_nopen(sop(:,:,ikconf),n_int)
    
       ! Number of ket CSFs
       knsp=ncsfs(knopen)

       ! Get the number of open shells preceding each ket conf MO
       call nobefore(sop(:,:,ikconf),nbefore)
       
       ! Loop over bra configurations
       do ibconf=ikconf+1,confdim

          ! Excitation degree
          nexci=exc_degree_conf(conf(:,:,ikconf),conf(:,:,ibconf),n_int)

          ! Cycle if the excitation degree is not equal to 1
          if (nexci /= 1) cycle

          ! Number of open shells in the bra configuration
          bnopen=sop_nopen(sop(:,:,ibconf),n_int)
    
          ! Number of bra CSFs
          bnsp=ncsfs(bnopen)

          ! Get the indices of the MOs involved in the excitation
          hlist=0
          plist=0
          call get_exci_indices(conf(:,:,ikconf),conf(:,:,ibconf),&
               n_int,hlist(1),plist(1),1)

          ! Get the spin-coupling coefficients
          scp(1:knsp,1:bnsp)=spincp_coeff(knsp,bnsp,&
               sop(:,:,ikconf),plist(1),hlist(1),knopen,nbefore)

          ! Idices of the 1-RDM elements
          i=m2c(hlist(1))
          a=m2c(plist(1))

          ! Loop over roots
          do ista=1,nroots

             ! Loop over bra CSFs
             bomega=0
             do ibcsf=offset(ibconf),offset(ibconf+1)-1
                bomega=bomega+1
                bcoe=vec(ibcsf,ista)

                ! Loop over ket CSFs
                komega=0
                do ikcsf=offset(ikconf),offset(ikconf+1)-1
                   komega=komega+1
                   kcoe=vec(ikcsf,ista)
                   
                   ! Contribution to the 1-RDM
                   prod=kcoe*bcoe*scp(komega,bomega)
                   rho(i,a,ista)=rho(i,a,ista)+prod
                   rho(a,i,ista)=rho(a,i,ista)+prod
                   
                enddo
             
             enddo
             
          enddo
          
       enddo

    enddo

!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(scp)
    
!----------------------------------------------------------------------
! Stop timing and print report
!----------------------------------------------------------------------
    call get_times(twall_end,tcpu_end)
    call report_times(twall_end-twall_start,tcpu_end-tcpu_start,&
         'rdm_double_loop')
    
    return
    
  end subroutine rdm_double_loop
    
!######################################################################

  function spincp_coeff(knsp,bnsp,sop,ac,ia,nopen,nbefore)

    use constants
    use bitglobal
    use pattern_indices
    use bitstrings
    use iomod
    
    implicit none

    ! Numbers of ket and bra CSFs
    integer(is), intent(in) :: knsp,bnsp

    ! SOP
    integer(ib), intent(in) :: sop(n_int,2)
    
    ! Creation/annihilation operator indices
    integer(is), intent(in) :: ac,ia

    ! Number of open shells
    integer(is), intent(in) :: nopen
    
    ! Number of open shells preceding each MO
    integer(is), intent(in) :: nbefore(nmo)

    ! Spin-coupling sub-case bit string encodings
    integer(is)             :: pattern
    integer(ib)             :: icase

    ! Function result
    real(dp)                :: spincp_coeff(knsp,bnsp)
    
    ! Everything else
    integer(is)             :: nc,na

!----------------------------------------------------------------------
! Get the pattern index and sub-case bit string for the spin-coupling
! coefficients
!----------------------------------------------------------------------
    ! No. open shells before the created electron
    nc=nbefore(ac)
    
    ! No. open shells before the annihilated electron
    na=nbefore(ia)

    ! Spin-coupling sub-case bit string
    icase=get_icase(sop,ac,ia)

    ! Pattern index
    pattern=pattern_index(sop,ac,ia,nc,na,nopen,icase)

!----------------------------------------------------------------------
! Fill in the array of spin-coupling coefficients
!----------------------------------------------------------------------
    select case(icase)
    case(i1a)
       spincp_coeff(1:knsp,1:bnsp)=spincp1(1:knsp,1:bnsp,pattern)
    case(i1b)
       spincp_coeff(1:knsp,1:bnsp)=-spincp1(1:knsp,1:bnsp,pattern)
    case(i2a)
       spincp_coeff(1:knsp,1:bnsp)=spincp2(1:knsp,1:bnsp,pattern)
    case(i2b)
       spincp_coeff(1:knsp,1:bnsp)=transpose(spincp2(1:bnsp,1:knsp,pattern))
    case default
       errmsg='Unrecognised icase value in spincp_coeff'
       call error_control
    end select
    
    return
    
  end function spincp_coeff
  
!######################################################################
  
end module rdm_double
