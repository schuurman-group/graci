!**********************************************************************
! Routines for the analysis of the MRCI configurations
!**********************************************************************
module confinfo

  implicit none

contains

!######################################################################
! get_active_mos: determines the subspace of MOs that are variably
!                 occupied across all configurations
!######################################################################
  subroutine get_active_mos(cfg,nactive,active)

    use constants
    use bitglobal
    use bitutils
    use conftype
    
    implicit none

    ! Configuration derived data type
    type(mrcfg), intent(in)  :: cfg

    ! Active MO information
    integer(is), intent(out) :: nactive
    integer(is), intent(out) :: active(nmo)
    
    ! Number of doubly-occupied and unoccupied MOs
    integer(is)              :: ndocc,nunocc

    ! Bit string encodings of the doubly-occupied, unoccupied
    ! and active MOs
    integer(ib)              :: Id(n_int),Iu(n_int),Ia(n_int)
    
    ! Everything else
    integer(is)              :: i,k,n,iconf,last

!----------------------------------------------------------------------
! Initialisation
!----------------------------------------------------------------------
    ! Doubly-occupied encoding
    Id=0_ib
    Id(1:cfg%n_int_I)=cfg%sop0h(:,2,1)

    ! Unoccupied encoding
    ! (Remember that 11...1 in two's complement is -1)
    do k=1,cfg%n_int_I
       Iu(k)=iand(not(cfg%conf0h(k,1,1)), not(cfg%conf0h(k,2,1)))
    enddo
    Iu(cfg%n_int_I+1:n_int)=-1_ib

!----------------------------------------------------------------------
! Reference configurations
!----------------------------------------------------------------------
    ! Loop over reference configurations
    do n=2,cfg%n0h

       ! Loop over blocks
       do k=1,cfg%n_int_I

          ! Doubly-occupied encoding
          Id(k)=iand(Id(k), cfg%sop0h(k,2,n))

          ! Unoccupied encoding
          Iu(k)=iand(Iu(k), not(cfg%conf0h(k,1,n)))
          Iu(k)=iand(Iu(k), not(cfg%conf0h(k,2,n)))
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! 1I configurations
!----------------------------------------------------------------------
    if (cfg%n1I > 0) then

       ! Loop over 1-hole configurations
       do n=1,cfg%n1h

          ! Loop over the 1I configurations generated by the
          ! current 1-hole configuration
          do iconf=cfg%off1I(n),cfg%off1I(n+1)-1

             ! Loop over blocks
             do k=1,n_int

                ! Doubly-occupied encoding
                Id(k)=iand(Id(k), cfg%sop1I(k,2,iconf))
                
                ! Unoccupied encoding
                Iu(k)=iand(Iu(k), not(cfg%conf1I(k,1,iconf)))
                Iu(k)=iand(Iu(k), not(cfg%conf1I(k,2,iconf)))
          
             enddo
             
          enddo
             
       enddo
       
    endif

!----------------------------------------------------------------------
! 1E configurations
!----------------------------------------------------------------------
    if (cfg%n1E > 0) then

       ! Loop over 1-hole configurations
       do n=1,cfg%n1h

          ! Loop over the 1E configurations generated by the
          ! current 1-hole configuration
          do iconf=cfg%off1E(n),cfg%off1E(n+1)-1

             ! Loop over blocks
             do k=1,n_int

                ! Doubly-occupied encoding
                Id(k)=iand(Id(k), cfg%sop1E(k,2,iconf))
                
                ! Unoccupied encoding
                Iu(k)=iand(Iu(k), not(cfg%conf1E(k,1,iconf)))
                Iu(k)=iand(Iu(k), not(cfg%conf1E(k,2,iconf)))
          
             enddo
             
          enddo
             
       enddo
       
    endif

!----------------------------------------------------------------------
! 2I configurations
!----------------------------------------------------------------------
    if (cfg%n2I > 0) then

       ! Loop over 2-hole configurations
       do n=1,cfg%n2h

          ! Loop over the 2I configurations generated by the
          ! current 2-hole configuration
          do iconf=cfg%off2I(n),cfg%off2I(n+1)-1

             ! Loop over blocks
             do k=1,n_int

                ! Doubly-occupied encoding
                Id(k)=iand(Id(k), cfg%sop2I(k,2,iconf))
                
                ! Unoccupied encoding
                Iu(k)=iand(Iu(k), not(cfg%conf2I(k,1,iconf)))
                Iu(k)=iand(Iu(k), not(cfg%conf2I(k,2,iconf)))
          
             enddo
             
          enddo
             
       enddo
       
    endif

!----------------------------------------------------------------------
! 2E configurations
!----------------------------------------------------------------------
    if (cfg%n2E > 0) then

       ! Loop over 2-hole configurations
       do n=1,cfg%n2h

          ! Loop over the 2E configurations generated by the
          ! current 2-hole configuration
          do iconf=cfg%off2E(n),cfg%off2E(n+1)-1

             ! Loop over blocks
             do k=1,n_int

                ! Doubly-occupied encoding
                Id(k)=iand(Id(k), cfg%sop2E(k,2,iconf))
                
                ! Unoccupied encoding
                Iu(k)=iand(Iu(k), not(cfg%conf2E(k,1,iconf)))
                Iu(k)=iand(Iu(k), not(cfg%conf2E(k,2,iconf)))
          
             enddo
             
          enddo
             
       enddo
       
    endif

!----------------------------------------------------------------------
! 1I1E configurations
!----------------------------------------------------------------------
    if (cfg%n1I1E > 0) then

       ! Loop over 2-hole configurations
       do n=1,cfg%n2h

          ! Loop over the 1I1E configurations generated by the
          ! current 2-hole configuration
          do iconf=cfg%off1I1E(n),cfg%off1I1E(n+1)-1

             ! Loop over blocks
             do k=1,n_int

                ! Doubly-occupied encoding
                Id(k)=iand(Id(k), cfg%sop1I1E(k,2,iconf))
                
                ! Unoccupied encoding
                Iu(k)=iand(Iu(k), not(cfg%conf1I1E(k,1,iconf)))
                Iu(k)=iand(Iu(k), not(cfg%conf1I1E(k,2,iconf)))
          
             enddo
             
          enddo
             
       enddo
       
    endif
    
!----------------------------------------------------------------------
! Clear the unused bits at the end of the unoccupied MO bit string
!----------------------------------------------------------------------
    last=nmo-(n_int-1)*n_bits
    Iu(n_int)=ibits(Iu(n_int),0,last)

!----------------------------------------------------------------------
! Bit string encoding of the active MO indices
!----------------------------------------------------------------------
    ! Ia = NOT(Id) AND NOT(Iu)
    do k=1,n_int
       Ia(k)=iand(not(Id(k)), not(Iu(k)))
    enddo

    ! Clear the unused bits
    last=nmo-(n_int-1)*n_bits
    Ia(n_int)=ibits(Ia(n_int),0,last)
    
!----------------------------------------------------------------------
! Number of MOs in the different subspaces
!----------------------------------------------------------------------
    ! Doubly-occupied
    ndocc=0
    do k=1,n_int
       ndocc=ndocc+popcnt(Id(k))
    enddo
    
    ! Unoccupied
    nunocc=0
    do k=1,n_int
       nunocc=nunocc+popcnt(Iu(k))
    enddo
    
    ! Active
    nactive=0
    do k=1,n_int
       nactive=nactive+popcnt(Ia(k))
    enddo
    
!----------------------------------------------------------------------    
! List of active MO indices
!----------------------------------------------------------------------
    call list_from_bitstring(Ia,active,nmo)
    
    return
    
  end subroutine get_active_mos

!######################################################################
! ndocc_ref: returns the dimension of the subspace of MOs that are
!            doubly-occupied across all reference configurations
!######################################################################
  function ndocc_ref(cfg)

    use constants
    use bitglobal
    use bitutils
    use conftype
    
    implicit none

    ! Function result: the dimension of the doubly-occupied inactive
    ! space for the reference configurations
    integer(is)             :: ndocc_ref

    ! Configuration derived data type
    type(mrcfg), intent(in) :: cfg

    ! Bit string encodings of the doubly-occupied inactive MOs
    integer(ib)             :: Id(n_int)

    ! Everything else
    integer(is)             :: n,k
    
!----------------------------------------------------------------------
! Compute the bit string encoding of the doubly-occupied inactive MOs
!----------------------------------------------------------------------
    ! Initialisation
    Id=0_ib
    Id(1:cfg%n_int_I)=cfg%sop0h(:,2,1)

    ! Loop over reference configurations
    do n=2,cfg%n0h

       ! Loop over blocks
       do k=1,cfg%n_int_I

          ! Doubly-occupied encoding
          Id(k)=iand(Id(k), cfg%sop0h(k,2,n))
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! Number of doubly-occupied inactive MOs
!----------------------------------------------------------------------
    ndocc_ref=0
    do k=1,n_int
       ndocc_ref=ndocc_ref+popcnt(Id(k))
    enddo

    return
    
  end function ndocc_ref
  
!######################################################################
! get_ref_docc_mos: determines the subspace of MOs that are
!                   doubly-occupied across all reference configurations  
!######################################################################
  subroutine get_ref_docc_mos(cfg,ndocc,docc)

    use constants
    use bitglobal
    use bitutils
    use conftype

    implicit none

    ! Configuration derived data type
    type(mrcfg), intent(in)  :: cfg

    ! Doubly-occupied MO information
    integer(is), intent(out) :: ndocc
    integer(is), intent(out) :: docc(nmo)

    ! Bit string encoding of the doubly-occupied MOs
    integer(ib)              :: Id(n_int)

    ! Everything else
    integer(is)              :: n,k

!----------------------------------------------------------------------
! Compute the bit string encoding of the MOs that are doubly-occupied
! across all reference configurations
!----------------------------------------------------------------------
    ! Initialisation
    Id=0_ib
    Id(1:cfg%n_int_I)=cfg%sop0h(:,2,1)

    ! Loop over reference configurations
    do n=2,cfg%n0h

       ! Loop over blocks
       do k=1,cfg%n_int_I

          Id(k)=iand(Id(k), cfg%sop0h(k,2,n))
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! Size of the doubly-occupied space
!----------------------------------------------------------------------
    ndocc=0
    do k=1,n_int
       ndocc=ndocc+popcnt(Id(k))
    enddo

!----------------------------------------------------------------------
! List of doubly-occupied MO indices
!----------------------------------------------------------------------
    call list_from_bitstring(Id,docc,nmo)
    
    return
    
  end subroutine get_ref_docc_mos
    
!######################################################################
  
end module confinfo
