module hij_disk

  use constants
  
  implicit none

  ! Temporary Hij array
  real(dp), allocatable :: harr2(:,:)
  
contains

!######################################################################
! save_hij: builds and saves the non-zero off-diagonal elements of 
!           the MRCI Hamiltonian to disk
!######################################################################
  subroutine save_hij(hamscr,nrec,irrep,averageii,confdim,cfg)
    
    use constants
    use bitglobal
    use conftype
    use iomod
    use timing
    
    implicit none

    ! Hamiltonian scratch file number
    integer(is), intent(out) :: hamscr

    ! Number of records written to the Hamiltonian scratch file
    integer(is), intent(out) :: nrec
    
    ! Irrep number
    integer(is), intent(in)  :: irrep
    
    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)  :: confdim
    real(dp), intent(in)     :: averageii(confdim)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)  :: cfg
    
    ! I/O variables
    integer(is)              :: iscratch
    character(len=60)        :: hamfile
    character(len=2)         :: amult,airrep

    ! Buffer
    integer(is)              :: nbuf
    integer(is), allocatable :: ibuffer(:,:)
    real(dp), allocatable    :: hbuffer(:)

    ! Timing variables
    real(dp)                 :: tcpu_start,tcpu_end,twall_start,&
                                twall_end
    
!----------------------------------------------------------------------
! Start timing
!----------------------------------------------------------------------
    call get_times(twall_start,tcpu_start)

!----------------------------------------------------------------------
! Register the Hamiltonian scratch file
!----------------------------------------------------------------------
    write(amult,'(i0)') imult
    write(airrep,'(i0)') irrep
    call scratch_name('hij.mult'//trim(amult)//'.sym'&
         //trim(airrep),hamfile)
    call register_scratch_file(hamscr,hamfile)

!----------------------------------------------------------------------
! Open the Hamiltonian scratch file
!----------------------------------------------------------------------
    iscratch=scrunit(hamscr)
    open(iscratch,file=scrname(hamscr),form='unformatted',&
         status='unknown')

!----------------------------------------------------------------------
! Allocate arrays and initialise the buffer
!----------------------------------------------------------------------
    allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    harr2=0.0d0
    
    allocate(ibuffer(2,bufsize))
    ibuffer=0

    allocate(hbuffer(bufsize))
    hbuffer=0.0d0

    nrec=0
    nbuf=0

!----------------------------------------------------------------------
! (1) Bra and ket configurations generated by reference configurations
!----------------------------------------------------------------------
    call save_hij_0h_0h(iscratch,ibuffer,hbuffer,nrec,nbuf,averageii,&
         confdim,cfg)
    
!----------------------------------------------------------------------
! (2) Ket: reference configurations
!     Bra: 1-hole configurations -> 1I and 1E configurations
!----------------------------------------------------------------------
    call save_hij_0h_1h(iscratch,ibuffer,hbuffer,nrec,nbuf,averageii,&
         confdim,cfg)
    
!----------------------------------------------------------------------
! (3) Ket: reference configurations
!     Bra: 2-hole configurations -> 2I, 2E and 1I1E configurations
!----------------------------------------------------------------------
    call save_hij_0h_2h(iscratch,ibuffer,hbuffer,nrec,nbuf,averageii,&
         confdim,cfg)
    
!----------------------------------------------------------------------
! (4) Ket: 1-hole configurations -> 1I and 1E configurations
!     Bra: 1-hole configurations -> 1I and 1E configurations
!----------------------------------------------------------------------
    call save_hij_1h_1h(iscratch,ibuffer,hbuffer,nrec,nbuf,averageii,&
         confdim,cfg)

!----------------------------------------------------------------------
! (5)  Ket: 2-hole configurations -> 2I, 2E and 1I1E configurations
!      Bra: 1-hole configurations -> 1I and 1E configurations
!----------------------------------------------------------------------
    call save_hij_2h_1h(iscratch,ibuffer,hbuffer,nrec,nbuf,averageii,&
         confdim,cfg)

!----------------------------------------------------------------------
! (6)  Ket: 2-hole configurations -> 2I, 2E and 1I1E configurations
!      Bra: 2-hole configurations -> 2I, 2E and 1I1E configurations
!----------------------------------------------------------------------
    call save_hij_2h_2h(iscratch,ibuffer,hbuffer,nrec,nbuf,averageii,&
         confdim,cfg)
    
!----------------------------------------------------------------------
! Number of saved Hamiltonian matrix elements
!----------------------------------------------------------------------
    write(6,'(/,x,a,x,i0)') 'Number of saved matrix elements:', &
         nrec*bufsize+nbuf

!----------------------------------------------------------------------
! Write the remaining elements in the buffer to disk
!----------------------------------------------------------------------
    if (nbuf > 0) then
       write(iscratch) hbuffer,ibuffer,nbuf
       nrec=nrec+1
    endif

!----------------------------------------------------------------------
! Close the Hamiltonian scratch file
!----------------------------------------------------------------------
    close(iscratch)

!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(ibuffer)
    deallocate(hbuffer)
    deallocate(harr2)
    
!----------------------------------------------------------------------
! Stop timing and print report
!----------------------------------------------------------------------
    call get_times(twall_end,tcpu_end)
    call report_times(twall_end-twall_start,tcpu_end-tcpu_start,&
         'save_hij')

    return
    
  end subroutine save_hij

!######################################################################
! save_hij_0h_0h: saves the non-zero Hamiltonian matrix elements
!                 corresponding to bra and ket CSFs generated by
!                 reference configurations
!######################################################################
  subroutine save_hij_0h_0h(iscratch,ibuffer,hbuffer,nrec,nbuf,&
       averageii,confdim,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    use timing
    
    implicit none

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg
    
    ! Difference configuration information
    integer(is)                :: ndiff
    integer(is)                :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is)                :: nbefore(nmo)

    ! MO classes
    integer(is)                :: socc(nmo),docc(nmo),unocc(nmo)
    integer(is)                :: nopen,nsocc,ndocc,nunocc
    
    ! Temporary Hij array
    integer(is)               :: arrdim
    real(dp), allocatable     :: harr(:)
    
    ! Working arrays
    integer(ib)                :: conf_full(n_int,2)
    integer(ib)                :: sop_full(n_int,2)
    integer(ib)                :: bconf_full(n_int,2),kconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2),ksop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: iconf,bconf,kconf,kcsf,bcsf
    integer(is)                :: bomega,komega
    integer(is)                :: bnopen,knopen
    integer(is)                :: nsp,k,bnsp,knsp
    integer(is)                :: nexci
    integer(is)                :: n_int_I

    ! Timing variables
    real(dp)                   :: tcpu_start,tcpu_end,twall_start,&
                                  twall_end
    
!----------------------------------------------------------------------
! Start timing
!----------------------------------------------------------------------
    call get_times(twall_start,tcpu_start)
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(harr(ncsfs(nomax)**2))
    harr=0.0d0

!----------------------------------------------------------------------
! (1) Off-diagonal elements between CSFs with the same spatial part,
!     but different spin couplings
!----------------------------------------------------------------------
    n_int_I=cfg%n_int_I
    
    ! Loop over reference configurations
    do iconf=1,cfg%n0h
       
       ! Number of open shells
       nopen=sop_nopen(cfg%sop0h(:,:,iconf),n_int_I)

       ! Number of CSFs generated by the configuration
       nsp=ncsfs(nopen)

       ! Cycle if there is only one CSF
       if (nsp == 1) cycle
       
       ! Configuration and SOP in the full MO space
       conf_full=0_ib
       sop_full=0_ib
       conf_full(1:n_int_I,:)=cfg%conf0h(:,:,iconf)
       sop_full(1:n_int_I,:)=cfg%sop0h(:,:,iconf)

       ! Get all the configuration information needed to evaluate
       ! the on-diagonal Hamiltonian matrix element
       call package_confinfo(sop_full,conf_full,unocc,socc,docc,&
            nunocc,nsocc,ndocc,Dw,ndiff,nbefore)
       
       ! Compute the Hamiltonian matrix elements
       arrdim=nsp*(nsp-1)/2
       call hij_same_mrci(harr(1:arrdim),arrdim,sop_full,socc,&
            nsocc,nbefore,cfg%m2c)

       ! Retrieve the Hamiltonian matrix elements and indices
       k=0
       ! Loop over ket CSFs
       do kcsf=cfg%csfs0h(iconf),cfg%csfs0h(iconf+1)-2
          ! Loop over bra CSFs
          do bcsf=kcsf+1,cfg%csfs0h(iconf+1)-1

             ! Increment the element counter
             k=k+1
             ! Save the matrix element if it is above threshold
             if (abs(harr(k)) > epshij) then
                nbuf=nbuf+1
                ibuffer(1,nbuf)=bcsf
                ibuffer(2,nbuf)=kcsf
                hbuffer(nbuf)=harr(k)
                if (nbuf == bufsize) call dump_buffer(iscratch,&
                     hbuffer,ibuffer,nbuf,nrec)
             endif
             
          enddo
       enddo

    enddo
    
!----------------------------------------------------------------------
! (2) Off-diagonal elements between CSFs with different spatial parts
!----------------------------------------------------------------------
    ! Loop over ket configurations
    do kconf=1,cfg%n0h-1

       ! Number of open shells in the ket configuration
       knopen=sop_nopen(cfg%sop0h(:,:,kconf),n_int_I)

       ! Number of ket CSFs
       knsp=ncsfs(knopen)
       
       ! Ket configuration and SOP in the full MO space
       kconf_full=0_ib
       ksop_full=0_ib
       kconf_full(1:n_int_I,:)=cfg%conf0h(:,:,kconf)
       ksop_full(1:n_int_I,:)=cfg%sop0h(:,:,kconf)

       ! Package the ket configuration information
       call package_confinfo(ksop_full,kconf_full,unocc,socc,docc,&
            nunocc,nsocc,ndocc,Dw,ndiff,nbefore)

       ! Loop over bra configurations
       do bconf=kconf+1,cfg%n0h
        
          ! Compute the excitation degree between the two
          ! configurations
          nexci=exc_degree_conf(cfg%conf0h(:,:,kconf),&
               cfg%conf0h(:,:,bconf),n_int_I)
          
          ! Cycle if the excitation degree is greater than 2
          if (nexci > 2) cycle

          ! Number of open shells in the bra configuration
          bnopen=sop_nopen(cfg%sop0h(:,:,bconf),n_int_I)

          ! Number of bra CSFs
          bnsp=ncsfs(bnopen)
          
          ! Bra configuration and SOP in the full MO space
          bconf_full=0_ib
          bsop_full=0_ib
          bconf_full(1:n_int_I,:)=cfg%conf0h(:,:,bconf)
          bsop_full(1:n_int_I,:)=cfg%sop0h(:,:,bconf)

          ! Get the indices of the MOs involved in the excitation
          hlist=0
          plist=0
          call get_exci_indices(cfg%conf0h(:,:,kconf),&
               cfg%conf0h(:,:,bconf),n_int_I,hlist(1:nexci),&
               plist(1:nexci),nexci)

          ! Compute the matrix elements between the CSFs generated
          ! by the bra and ket configurations
          call hij_mrci(harr2,ncsfs(nomax),nexci,bconf,kconf,&
               bsop_full,ksop_full,bnsp,knsp,bnopen,knopen,&
               hlist,plist,cfg%m2c,socc,nsocc,nbefore,Dw,ndiff,&
               cfg%csfs0h,cfg%csfs0h,cfg%n0h+1,cfg%n0h+1,&
               averageii(bconf),averageii(kconf))
          
          ! Save the above-threshold matrix elements
          call save_above_threshold(bconf,kconf,&
               cfg%csfs0h,cfg%csfs0h,cfg%n0h+1,cfg%n0h+1,&
               bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
             
       enddo
          
    enddo
    
!----------------------------------------------------------------------
! Dellocate arrays
!----------------------------------------------------------------------
    deallocate(harr)
    
!----------------------------------------------------------------------
! Stop timing and print report
!----------------------------------------------------------------------
    call get_times(twall_end,tcpu_end)
    call report_times(twall_end-twall_start,tcpu_end-tcpu_start,&
         'save_hij_0h_0h')
    return
    
  end subroutine save_hij_0h_0h

!######################################################################
! save_hij_0h_1h: saves the non-zero Hamiltonian matrix elements
!                 corresponding to CSFs generated by reference and
!                 1-hole configurations
!######################################################################
  subroutine save_hij_0h_1h(iscratch,ibuffer,hbuffer,nrec,nbuf,&
       averageii,confdim,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use mrci_integrals
    use timing
    
    implicit none

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg
    
    ! Difference configuration information
    integer(is)                :: ndiff
    integer(is)                :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is)                :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is)                :: socc(nmo)
    integer(is)                :: nsocc
        
    ! Working arrays
    integer(ib)                :: kconf_full(n_int,2)
    integer(ib)                :: ksop_full(n_int,2)
    
    ! Everything else
    integer(is)                :: ibconf1I,ibconf1E,kconf
    integer(is)                :: knopen,nac
    integer(is)                :: n,bnsp,knsp
    integer(is)                :: n_int_I
    
    ! Timing variables
    real(dp)                   :: tcpu_start,tcpu_end,twall_start,&
                                  twall_end
    
!----------------------------------------------------------------------
! Start timing
!----------------------------------------------------------------------
    call get_times(twall_start,tcpu_start)
    
!----------------------------------------------------------------------
! Off-diagonal elements in the R-1I and R-1E classes
!----------------------------------------------------------------------
    n_int_I=cfg%n_int_I

    ! Loop over ket reference configurations
    do kconf=1,cfg%n0h

       ! Number of open shells in the ket configuration
       knopen=sop_nopen(cfg%sop0h(:,:,kconf),n_int_I)

       ! Number of ket CSFs
       knsp=ncsfs(knopen)
       
       ! Ket configuration and SOP in the full MO space
       kconf_full=0_ib
       ksop_full=0_ib
       kconf_full(1:n_int_I,:)=cfg%conf0h(:,:,kconf)
       ksop_full(1:n_int_I,:)=cfg%sop0h(:,:,kconf)

       ! Package the ket configuration information
       call package_confinfo_offdiag(ksop_full,kconf_full,socc,nsocc,&
            Dw,ndiff,nbefore)
       
       ! Loop over 1-hole configurations
       ibconf1I=0
       ibconf1E=0
       do n=1,cfg%n1h

          ! Number of creation and annihilation operators linking the
          ! reference and 1-hole configurations
          nac=n_create_annihilate(cfg%conf0h(1:n_int_I,:,kconf), &
               cfg%conf1h(1:n_int_I,:,n),n_int_I)

          ! Ref - 1I matrix elements
          if (nac <= 5) then
             if (cfg%n1I > 0) then
                call save_hij_0h_1I(n,kconf,ibconf1I,ksop_full,&
                     ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                     averageii,confdim,iscratch,hbuffer,ibuffer,&
                     nbuf,nrec,n_int_I,cfg)
             endif
          else
             ibconf1I=ibconf1I+cfg%off1I(n+1)-cfg%off1I(n)
          endif
          
          ! Ref - 1E matrix elements
          if (nac <= 3) then
             if (cfg%n1E > 0) then
                call save_hij_0h_1E(n,kconf,ibconf1E,n_int_I,&
                     kconf_full,ksop_full,ndiff,Dw,nbefore,socc,nsocc,&
                     knopen,knsp,averageii,confdim,iscratch,hbuffer,&
                     ibuffer,nbuf,nrec,cfg)
             endif
          else
             ibconf1E=ibconf1E+cfg%off1E(n+1)-cfg%off1E(n)
          endif
             
       enddo
       
    enddo

!----------------------------------------------------------------------
! Stop timing and print report
!----------------------------------------------------------------------
    call get_times(twall_end,tcpu_end)
    call report_times(twall_end-twall_start,tcpu_end-tcpu_start,&
         'save_hij_0h_1h')
    
    return
    
  end subroutine save_hij_0h_1h

!######################################################################

  subroutine save_hij_0h_2h(iscratch,ibuffer,hbuffer,nrec,nbuf,&
       averageii,confdim,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use mrci_integrals
    use timing
    
    implicit none
    
    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Difference configuration information
    integer(is)                :: ndiff
    integer(is)                :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is)                :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is)                :: socc(nmo)
    integer(is)                :: nsocc
    
    ! Working arrays
    integer(ib)                :: kconf_full(n_int,2)
    integer(ib)                :: ksop_full(n_int,2)
    
    ! Everything else
    integer(is)                :: ibconf2I,ibconf2E,ibconf1I1E,kconf
    integer(is)                :: knopen
    integer(is)                :: n,bnsp,knsp,nac,nexci
    integer(is)                :: n_int_I
    integer(is)                :: bref
    
    ! Timing variables
    real(dp)                   :: tcpu_start,tcpu_end,twall_start,&
                                  twall_end

!----------------------------------------------------------------------
! Start timing
!----------------------------------------------------------------------
    call get_times(twall_start,tcpu_start)
    
!----------------------------------------------------------------------
! Off-diagonal elements in the R-2I, R-2E and R-1I1E classes
!----------------------------------------------------------------------
    n_int_I=cfg%n_int_I
    
    ! Loop over ket reference configurations
    do kconf=1,cfg%n0h
       
       ! Number of open shells in the ket configuration
       knopen=sop_nopen(cfg%sop0h(:,:,kconf),n_int_I)
    
       ! Number of ket CSFs
       knsp=ncsfs(knopen)
       
       ! Ket configuration and SOP in the full MO space
       kconf_full=0_ib
       ksop_full=0_ib
       kconf_full(1:n_int_I,:)=cfg%conf0h(:,:,kconf)
       ksop_full(1:n_int_I,:)=cfg%sop0h(:,:,kconf)
    
       ! Package the ket configuration information
       call package_confinfo_offdiag(ksop_full,kconf_full,socc,nsocc,&
            Dw,ndiff,nbefore)
       
       ! Loop over 2-hole configurations
       ibconf2I=0
       ibconf2E=0
       ibconf1I1E=0
       do n=1,cfg%n2h
    
          ! Number of creation and annihilation operators linking the
          ! reference and 2-hole configurations
          nac=n_create_annihilate(cfg%conf0h(1:n_int_I,:,kconf),&
               cfg%conf2h(1:n_int_I,:,n),n_int_I)
          
          ! Ref - 2I matrix elements
          if (nac <= 6) then
             if (cfg%n2I > 0) then
                call save_hij_0h_2I(n,kconf,ibconf2I,n_int_I,&
                     ksop_full,ndiff,Dw,nbefore,socc,nsocc,knopen,&
                     knsp,averageii,confdim,iscratch,hbuffer,ibuffer,&
                     nbuf,nrec,cfg)
             endif
          else
             ibconf2I=ibconf2I+cfg%off2I(n+1)-cfg%off2I(n)
          endif
             
          ! Ref - 2E matrix elements
          if (nac <= 2) then
             if (cfg%n2E > 0) then
                call save_hij_0h_2E(n,kconf,ibconf2E,n_int_I,&
                     kconf_full,ksop_full,ndiff,Dw,nbefore,socc,&
                     nsocc,knopen,knsp,averageii,confdim,iscratch,&
                     hbuffer,ibuffer,nbuf,nrec,cfg)
             endif
          else
             ibconf2E=ibconf2E+cfg%off2E(n+1)-cfg%off2E(n)
          endif
          
          ! Ref - 1I1E matrix elements
          if (nac <= 4) then
             if (cfg%n1I1E > 0) then
                call save_hij_0h_1I1E(n,kconf,ibconf1I1E,n_int_I,&
                     kconf_full,ksop_full,ndiff,Dw,nbefore,socc,nsocc,&
                     knopen,knsp,averageii,confdim,iscratch,hbuffer,&
                     ibuffer,nbuf,nrec,cfg)
             endif
          else
             ibconf1I1E=ibconf1I1E+cfg%off1I1E(n+1)-cfg%off1I1E(n)
          endif
          
       enddo
    
    enddo

!----------------------------------------------------------------------
! Stop timing and print report
!----------------------------------------------------------------------
    call get_times(twall_end,tcpu_end)
    call report_times(twall_end-twall_start,tcpu_end-tcpu_start,&
         'save_hij_0h_2h')

    return
    
  end subroutine save_hij_0h_2h

!######################################################################

  subroutine save_hij_1h_1h(iscratch,ibuffer,hbuffer,nrec,nbuf,&
       averageii,confdim,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use mrci_integrals
    use timing

    implicit none

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Difference configuration information
    integer(is)                :: ndiff
    integer(is)                :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is)                :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is)                :: socc(nmo)
    integer(is)                :: nsocc
    
    ! Working arrays
    integer(ib), allocatable   :: kconf_int(:,:)
    integer(ib), allocatable   :: ksop_int(:,:)
    integer(ib)                :: kconf_full(n_int,2)
    integer(ib)                :: bconf1h_full(n_int,2)
    integer(ib)                :: ksop_full(n_int,2)
    integer(is), parameter     :: maxexci=3
    integer(is)                :: hlist(maxexci),plist(maxexci)
    
    ! Everything else
    integer(is)                :: knopen
    integer(is)                :: kn,bn,bnsp,knsp,nac1,nac,nexci
    integer(is)                :: n_int_I
    integer(is)                :: bref
    integer(is)                :: ioff
    
    ! Timing variables
    real(dp)                   :: tcpu_start,tcpu_end,twall_start,&
                                  twall_end

!----------------------------------------------------------------------
! Start timing
!----------------------------------------------------------------------
    call get_times(twall_start,tcpu_start)

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    n_int_I=cfg%n_int_I

    allocate(kconf_int(n_int_I,2))
    allocate(ksop_int(n_int_I,2))
    kconf_int=0_ib
    ksop_int=0_ib
    
!----------------------------------------------------------------------
! Off-diagonal elements in the 1I-1I, 1I-1E and 1E-1E classes
!----------------------------------------------------------------------
    ! Loop over ket 1-hole configurations
    do kn=1,cfg%n1h
    
       ! Loop over bra 1-hole configurations
       do bn=kn,cfg%n1h
          
          ! Bra 1-hole configuration in the full MO space
          bconf1h_full=0_ib
          bconf1h_full(1:n_int_I,:)=cfg%conf1h(1:n_int_I,:,bn)
          
          ! Number of creation and annihilation operators linking the
          ! bra and ket 1-hole configurations
          nac1=n_create_annihilate(cfg%conf1h(1:n_int_I,:,kn),&
               cfg%conf1h(1:n_int_I,:,bn),n_int_I)
    
          ! Cycle if the full configurations generated by the 1-hole
          ! configurations cannot be interacting
          if (nac1 > 6) cycle
          
          ! Get the indices of the creation and annihilation operators
          ! linking the bra and ket 1-hole configurations
          hlist=0
          plist=0
          nexci=nac1/2
          if (nexci > 0) &
               call get_exci_indices(cfg%conf1h(:,:,kn),&
               cfg%conf1h(:,:,bn),n_int_I,hlist(1:nexci),&
               plist(1:nexci),nexci)
    
          !
          ! Ket 1I, bra 1I and 1E matrix elements
          !
          if (cfg%n1I > 0) then
             ! Loop over ket 1I configurations
             do ioff=cfg%off1I(kn),cfg%off1I(kn+1)-1
          
                ! Ket 1I configuration
                kconf_int=cfg%conf1I(1:n_int_I,:,ioff)
                ksop_int=cfg%sop1I(1:n_int_I,:,ioff)
                kconf_full=0_ib
                ksop_full=0_ib
                kconf_full(1:n_int_I,:)=kconf_int
                ksop_full(1:n_int_I,:)=ksop_int
                
                ! Number of creation and annihilation operators linking
                ! the ket 1I and bra 1-hole configurations
                nac=n_create_annihilate(kconf_int,&
                     cfg%conf1h(1:n_int_I,:,bn),n_int_I)
                
                ! Cycle if the the bra 1-hole configuration cannot
                ! generate configurations that interact with the
                ! ket 1I configuration
                if (nac > 5) cycle
                
                ! Number of open shells in the ket 1I configuration
                knopen=sop_nopen(ksop_int(1:n_int_I,:),n_int_I)
                
                ! Number of ket 1I CSFs
                knsp=ncsfs(knopen)
                
                ! Package the ket 1I configuration information
                call package_confinfo_offdiag(ksop_full,kconf_full,&
                     socc,nsocc,Dw,ndiff,nbefore)
                
                ! 1I - 1I matrix elements
                if (nac <= 5 &
                     .and. cfg%off1I(bn) /= cfg%off1I(bn+1)) then
                   call save_hij_1I_1I(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
          
                ! 1I - 1E matrix elements
                if (nac <= 3 &
                     .and. cfg%off1E(bn) /= cfg%off1E(bn+1)) then
                   call save_hij_1I_1E(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
          
             enddo
          
          endif
          
          !
          ! Ket 1E, bra 1E matrix elements
          !
          ! Cycle if the bra 1-hole configuration doesn't generate
          ! any 1E configurations
          if (cfg%off1E(bn) == cfg%off1E(bn+1)) cycle
          
          ! Cycle if the the bra and ket 1-hole configurations
          ! cannot generate interacting 1E configurations
          if (nac1 > 4) cycle
          
          ! Loop over ket 1E configurations
          do ioff=cfg%off1E(kn),cfg%off1E(kn+1)-1
             
             ! Ket 1E configuration
             kconf_full=cfg%conf1E(:,:,ioff)
             ksop_full=cfg%sop1E(:,:,ioff)
             
             ! Number of open shells in the ket 1E configuration
             knopen=sop_nopen(ksop_full,n_int)
                
             ! Number of ket 1E CSFs
             knsp=ncsfs(knopen)
             
             ! Package the ket 1E configuration information
             call package_confinfo_offdiag(ksop_full,kconf_full,socc,&
                  nsocc,Dw,ndiff,nbefore)
          
             
             ! Note that knopen, nsocc, etc can be determined from
             ! their values computed using the ket 1H conf and
             ! the index of the external creation operator...
             
             
             ! 1E - 1E matrix elements
             call save_hij_1E_1E(nac1,hlist,plist,maxexci,bn,&
                  ioff,kconf_full,ksop_full,n_int_I,ndiff,Dw,nbefore,&
                  socc,nsocc,knopen,knsp,averageii,confdim,iscratch,&
                  hbuffer,ibuffer,nbuf,nrec,cfg)
             
          enddo
          
       enddo
       
    enddo

!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(kconf_int)
    deallocate(ksop_int)
    
!----------------------------------------------------------------------
! Stop timing and print report
!----------------------------------------------------------------------
    call get_times(twall_end,tcpu_end)
    call report_times(twall_end-twall_start,tcpu_end-tcpu_start,&
         'save_hij_1h_1h')

    return
    
  end subroutine save_hij_1h_1h

!######################################################################

  subroutine save_hij_2h_1h(iscratch,ibuffer,hbuffer,nrec,nbuf,&
       averageii,confdim,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use mrci_integrals
    use timing

    implicit none

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Difference configuration information
    integer(is)                :: ndiff
    integer(is)                :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is)                :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is)                :: socc(nmo)
    integer(is)                :: nsocc
    
    ! Working arrays
    integer(ib), allocatable   :: kconf_int(:,:)
    integer(ib), allocatable   :: ksop_int(:,:)
    integer(ib)                :: kconf_full(n_int,2)
    integer(ib)                :: bconf1h_full(n_int,2)
    integer(ib)                :: ksop_full(n_int,2)
    integer(is), parameter     :: maxexci=4
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: knopen
    integer(is)                :: kn,bn,bnsp,knsp,nac1,nac,nexci
    integer(is)                :: n_int_I
    integer(is)                :: bref
    integer(is)                :: ioff
    
    ! Timing variables
    real(dp)                   :: tcpu_start,tcpu_end,twall_start,&
                                  twall_end

!----------------------------------------------------------------------
! Start timing
!----------------------------------------------------------------------
    call get_times(twall_start,tcpu_start)

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    n_int_I=cfg%n_int_I

    allocate(kconf_int(n_int_I,2))
    allocate(ksop_int(n_int_I,2))
    kconf_int=0_ib
    ksop_int=0_ib

!----------------------------------------------------------------------
! Off-diagonal elements in the 1I-2I, 1I-2E, 1I-1I1E, 1E-2I, 1E-2E,
! and 1I-1I1E classes
!----------------------------------------------------------------------
    ! Loop over ket 2-hole configurations
    do kn=1,cfg%n2h
    
       ! Loop over bra 1-hole configurations
       do bn=1,cfg%n1h
          
          ! Bra 1-hole configuration in the full MO space
          bconf1h_full=0_ib
          bconf1h_full(1:n_int_I,:)=cfg%conf1h(1:n_int_I,:,bn)

          ! Number of creation and annihilation operators linking the
          ! bra and ket 1- and 2-hole configurations
          nac1=n_create_annihilate(cfg%conf2h(1:n_int_I,:,kn),&
               cfg%conf1h(1:n_int_I,:,bn),n_int_I)

          ! Cycle if the full configurations generated by the hole
          ! configurations cannot be interacting
          if (nac1 > 7) cycle

          ! Get the indices of the creation and annihilation operators
          ! linking the bra 1-hole and ket 2-hole configurations
          !********************************************************
          !* Note that here there will be 1 more creation operator *
          !* than annihilation operators                           *
          !*********************************************************
          hlist=0
          plist=0
          nexci=(nac1+1)/2
          call get_exci_indices(cfg%conf2h(:,:,kn),&
               cfg%conf1h(:,:,bn),n_int_I,hlist(1:nexci),&
               plist(1:nexci),nexci)

          !
          ! Ket: 2I
          ! Bra: 1I and 1E
          !
          if (cfg%n2I > 0) then

             ! Loop over ket 2I configurations
             do ioff=cfg%off2I(kn),cfg%off2I(kn+1)-1

                ! Ket 2I configuration
                kconf_int=cfg%conf2I(1:n_int_I,:,ioff)
                ksop_int=cfg%sop2I(1:n_int_I,:,ioff)
                kconf_full=0_ib
                ksop_full=0_ib
                kconf_full(1:n_int_I,:)=kconf_int
                ksop_full(1:n_int_I,:)=ksop_int
                
                ! Number of creation and annihilation operators linking
                ! the ket 2I and bra 1-hole configurations
                nac=n_create_annihilate(kconf_int,&
                     cfg%conf1h(1:n_int_I,:,bn),n_int_I)

                ! Cycle if the the bra 1-hole configuration cannot
                ! generate configurations that interact with the
                ! ket 2I configuration
                if (nac > 5) cycle

                ! Number of open shells in the ket 2I configuration
                knopen=sop_nopen(ksop_int(1:n_int_I,:),n_int_I)
                
                ! Number of ket 2I CSFs
                knsp=ncsfs(knopen)
                
                ! Package the ket 2I configuration information
                call package_confinfo_offdiag(ksop_full,kconf_full,&
                     socc,nsocc,Dw,ndiff,nbefore)

                ! 2I - 1I matrix elements
                if (nac <= 5 &
                     .and. cfg%off1I(bn) /= cfg%off1I(bn+1)) then
                   call save_hij_2I_1I(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
                
                ! 2I - 1E matrix elements
                if (nac <= 3 &
                     .and. cfg%off1E(bn) /= cfg%off1E(bn+1)) then
                   call save_hij_2I_1E(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
                
             enddo
                
          endif

          !
          ! Ket: 2E
          ! Bra: 1I and 1E
          !
          if (cfg%n2E > 0 .and. nac1 <= 3) then
             
             ! Loop over ket 2E configurations
             do ioff=cfg%off2E(kn),cfg%off2E(kn+1)-1

                ! Ket 2E configuration
                kconf_full=cfg%conf2E(:,:,ioff)
                ksop_full=cfg%sop2E(:,:,ioff)
                
                ! Number of creation and annihilation operators linking
                ! the ket 2E and bra 1-hole configurations
                !nac=n_create_annihilate(kconf_full,bconf1h_full,n_int)
                !
                !! Cycle if the the bra 1-hole configuration cannot
                !! generate configurations that interact with the
                !! ket 2E configuration
                !if (nac > 5) cycle

                ! Number of open shells in the ket 2E configuration
                knopen=sop_nopen(ksop_full,n_int)
                
                ! Number of ket 2E CSFs
                knsp=ncsfs(knopen)
                
                ! Package the ket 2E configuration information
                call package_confinfo_offdiag(ksop_full,kconf_full,&
                     socc,nsocc,Dw,ndiff,nbefore)

                ! 2E - 1I matrix elements
                if (cfg%n1I > 0) then
                   if (cfg%off1I(bn) /= cfg%off1I(bn+1)) then
                      call save_hij_2E_1I(bn,ioff,kconf_full,&
                           ksop_full,kconf_int,ksop_int,n_int_I,&
                           ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                           averageii,confdim,iscratch,hbuffer,ibuffer,&
                           nbuf,nrec,cfg)
                   endif
                endif
                   
                ! 2E - 1E matrix elements
                if (cfg%off1E(bn) /= cfg%off1E(bn+1)) then
                   call save_hij_2E_1E(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
                
             enddo
             
          endif

          !
          ! Ket: 1I1E
          ! Bra: 1I and 1E
          !
          if (cfg%n1I1E > 0) then

             ! Loop over ket 1I1E configurations
             do ioff=cfg%off1I1E(kn),cfg%off1I1E(kn+1)-1

                ! Ket 1I1E configuration
                kconf_full=cfg%conf1I1E(:,:,ioff)
                ksop_full=cfg%sop1I1E(:,:,ioff)

                ! Number of creation and annihilation operators linking
                ! the ket 1I1E and bra 1-hole configurations
                nac=n_create_annihilate(kconf_full,bconf1h_full,n_int)

                ! Cycle if the the bra 1-hole configuration cannot
                ! generate configurations that interact with the
                ! ket 1I1E configuration
                if (nac > 5) cycle

                ! Number of open shells in the ket 1I1E configuration
                knopen=sop_nopen(ksop_full,n_int)
                
                ! Number of ket 1I1E CSFs
                knsp=ncsfs(knopen)

                ! Package the ket 1I1E configuration information
                call package_confinfo_offdiag(ksop_full,kconf_full,&
                     socc,nsocc,Dw,ndiff,nbefore)

                ! 1I1E - 1I matrix elements
                if (cfg%off1I(bn) /= cfg%off1I(bn+1)) then
                   call save_hij_1I1E_1I(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif

                ! 1I1E - 1E matrix elements
                if (cfg%off1E(bn) /= cfg%off1E(bn+1)) then
                   call save_hij_1I1E_1E(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
                
             enddo
                
          endif
             
       enddo

    enddo
       
!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(kconf_int)
    deallocate(ksop_int)
    
!----------------------------------------------------------------------
! Stop timing and print report
!----------------------------------------------------------------------
    call get_times(twall_end,tcpu_end)
    call report_times(twall_end-twall_start,tcpu_end-tcpu_start,&
         'save_hij_2h_1h')
    
    return
    
  end subroutine save_hij_2h_1h

!######################################################################

  subroutine save_hij_2h_2h(iscratch,ibuffer,hbuffer,nrec,nbuf,&
       averageii,confdim,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use mrci_integrals
    use timing

    implicit none

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Difference configuration information
    integer(is)                :: ndiff
    integer(is)                :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is)                :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is)                :: socc(nmo)
    integer(is)                :: nsocc
    
    ! Working arrays
    integer(ib), allocatable   :: kconf_int(:,:)
    integer(ib), allocatable   :: ksop_int(:,:)
    integer(ib)                :: kconf_full(n_int,2)
    integer(ib)                :: bconf2h_full(n_int,2)
    integer(ib)                :: ksop_full(n_int,2)
    integer(is), parameter     :: maxexci=4
    integer(is)                :: hlist(maxexci),plist(maxexci) 

    ! Everything else
    integer(is)                :: knopen
    integer(is)                :: kn,bn,bnsp,knsp,nac1,nac,nexci
    integer(is)                :: n_int_I
    integer(is)                :: bref
    integer(is)                :: ioff
    
    ! Timing variables
    real(dp)                   :: tcpu_start,tcpu_end,twall_start,&
                                  twall_end
    
!----------------------------------------------------------------------
! Start timing
!----------------------------------------------------------------------
    call get_times(twall_start,tcpu_start)

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    n_int_I=cfg%n_int_I

    allocate(kconf_int(n_int_I,2))
    allocate(ksop_int(n_int_I,2))
    kconf_int=0_ib
    ksop_int=0_ib

!----------------------------------------------------------------------
! Off-diagonal elements in the 2I-2I, 2I-2E, 2I-1I1E, 2E-2E,
! 2I-1I1E, and 1I1E-1I1E classes
!----------------------------------------------------------------------
    ! Loop over ket 2-hole configurations
    do kn=1,cfg%n2h
    
       ! Loop over bra 2-hole configurations
       do bn=kn,cfg%n2h

          ! Bra 2-hole configuration in the full MO space
          bconf2h_full=0_ib
          bconf2h_full(1:n_int_I,:)=cfg%conf2h(1:n_int_I,:,bn)

          ! Number of creation and annihilation operators linking the
          ! bra and ket 2-hole configurations
          nac1=n_create_annihilate(cfg%conf2h(1:n_int_I,:,kn),&
               cfg%conf2h(1:n_int_I,:,bn),n_int_I)

          ! Cycle if the full configurations generated by the hole
          ! configurations cannot be interacting
          if (nac1 > 8) cycle

          ! Get the indices of the creation and annihilation operators
          ! linking the bra and ket 2-hole configurations
          hlist=0
          plist=0
          nexci=nac1/2
          call get_exci_indices(cfg%conf2h(:,:,kn),&
               cfg%conf2h(:,:,bn),n_int_I,hlist(1:nexci),&
               plist(1:nexci),nexci)

          !
          ! Ket: 2I
          ! Bra: 2I, 2E and 1I1E
          !
          if (cfg%n2I > 0) then
          
             ! Loop over ket 2I configurations
             do ioff=cfg%off2I(kn),cfg%off2I(kn+1)-1
          
                ! Ket 2I configuration
                kconf_int=cfg%conf2I(1:n_int_I,:,ioff)
                ksop_int=cfg%sop2I(1:n_int_I,:,ioff)
                kconf_full=0_ib
                ksop_full=0_ib
                kconf_full(1:n_int_I,:)=kconf_int
                ksop_full(1:n_int_I,:)=ksop_int
          
                ! Number of creation and annihilation operators linking
                ! the ket 2I and bra 2-hole configurations
                nac=n_create_annihilate(kconf_int,&
                     cfg%conf2h(1:n_int_I,:,bn),n_int_I)
          
                ! Cycle if the the bra 2-hole configuration cannot
                ! generate configurations that interact with the
                ! ket 2I configuration
                if (nac > 6) cycle
          
                ! Number of open shells in the ket 2I configuration
                knopen=sop_nopen(ksop_int(1:n_int_I,:),n_int_I)
                
                ! Number of ket 2I CSFs
                knsp=ncsfs(knopen)
                
                ! Package the ket 2I configuration information
                call package_confinfo_offdiag(ksop_full,kconf_full,&
                     socc,nsocc,Dw,ndiff,nbefore)
          
                ! 2I - 2I matrix elements
                if (nac <= 6 &
                     .and. cfg%off2I(bn) /= cfg%off2I(bn+1)) then
                   call save_hij_2I_2I(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
          
                ! 2I - 2E matrix elements
                if (nac <= 2 &
                     .and. cfg%n2E > 0 &
                     .and. cfg%off2E(bn) /= cfg%off2E(bn+1)) then
                   call save_hij_2I_2E(nac,bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
          
                ! 2I - 1I1E matrix elements
                if (nac <= 4 &
                     .and. cfg%n1I1E > 0 &
                     .and. cfg%off1I1E(bn) /= cfg%off1I1E(bn+1)) then
                   call save_hij_2I_1I1E(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
                   
             enddo
                
          endif

          !
          ! Ket: 2E
          ! Bra: 2E and 1I1E
          !
          if (cfg%n2E > 0 .and. nac1 <= 5) then

             ! Loop over ket 2E configurations
             do ioff=cfg%off2E(kn),cfg%off2E(kn+1)-1
          
                ! Ket 2E configuration
                kconf_full=cfg%conf2E(:,:,ioff)
                ksop_full=cfg%sop2E(:,:,ioff)
                kconf_int=0_ib
                ksop_int=0_ib
                kconf_int(1:n_int_I,:)=kconf_full(1:n_int_I,:)
                ksop_int(1:n_int_I,:)=ksop_full(1:n_int_I,:)
          
                ! Number of creation and annihilation operators linking
                ! the ket 2E and bra 2-hole configurations
                nac=n_create_annihilate(kconf_full,bconf2h_full,n_int)
          
                ! Cycle if the the bra 2-hole configuration cannot
                ! generate configurations that interact with the
                ! ket 2E configuration
                if (nac > 6) cycle
                
                ! Number of open shells in the ket 2E configuration
                knopen=sop_nopen(ksop_full,n_int)
                
                ! Number of ket 2E CSFs
                knsp=ncsfs(knopen)
          
                ! Package the ket 2E configuration information
                call package_confinfo_offdiag(ksop_full,kconf_full,&
                     socc,nsocc,Dw,ndiff,nbefore)
          
                ! 2E - 2E matrix elements
                if (cfg%off2E(bn) /= cfg%off2E(bn+1)) then
                   if (nac1 <= 4) then
                      call save_hij_2E_2E(nac1,hlist,plist,maxexci,&
                           bn,ioff,kconf_full,ksop_full,kconf_int,&
                           ksop_int,n_int_I,ndiff,Dw,nbefore,socc,&
                           nsocc,knopen,knsp,averageii,confdim,iscratch,&
                           hbuffer,ibuffer,nbuf,nrec,cfg)
                   endif
                endif
          
                ! 2E - 1I1E matrix elements
                if (cfg%off1I1E(bn) /= cfg%off1I1E(bn+1) &
                     .and. cfg%n1I1E /= 0) then
                   call save_hij_2E_1I1E(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
                   
             enddo
                
          endif
          
          !
          ! Ket: 1I1E
          ! Bra: 1I1E
          !
          if (cfg%n1I1E > 0) then
          
             ! Loop over ket 1I1E configurations
             do ioff=cfg%off1I1E(kn),cfg%off1I1E(kn+1)-1
                
                ! Ket 1I1E configuration
                kconf_full=cfg%conf1I1E(:,:,ioff)
                ksop_full=cfg%sop1I1E(:,:,ioff)
                kconf_int=0_ib
                ksop_int=0_ib
                kconf_int(1:n_int_I,:)=kconf_full(1:n_int_I,:)
                ksop_int(1:n_int_I,:)=ksop_full(1:n_int_I,:)
          
                ! Number of creation and annihilation operators linking
                ! the ket 2E and bra 2-hole configurations
                nac=n_create_annihilate(kconf_full,bconf2h_full,n_int)
          
                ! Cycle if the the bra 2-hole configuration cannot
                ! generate configurations that interact with the
                ! ket 1I1E configuration
                if (nac > 6) cycle
          
                ! Number of open shells in the ket 1I1E configuration
                knopen=sop_nopen(ksop_full,n_int)
                
                ! Number of ket 1I1E CSFs
                knsp=ncsfs(knopen)
          
                ! Package the ket 1I1E configuration information
                call package_confinfo_offdiag(ksop_full,kconf_full,&
                     socc,nsocc,Dw,ndiff,nbefore)
          
                ! 1I1E - 1I1E matrix elements
                if (cfg%off1I1E(bn) /= cfg%off1I1E(bn+1)) then
                   call save_hij_1I1E_1I1E(bn,ioff,kconf_full,&
                        ksop_full,kconf_int,ksop_int,n_int_I,&
                        ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,&
                        averageii,confdim,iscratch,hbuffer,ibuffer,&
                        nbuf,nrec,cfg)
                endif
                
             enddo
             
          endif
             
       enddo

    enddo
       
!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(kconf_int)
    deallocate(ksop_int)
    
!----------------------------------------------------------------------
! Stop timing and print report
!----------------------------------------------------------------------
    call get_times(twall_end,tcpu_end)
    call report_times(twall_end-twall_start,tcpu_end-tcpu_start,&
         'save_hij_2h_2h')
    
    return
    
  end subroutine save_hij_2h_2h
    
!######################################################################

  subroutine save_hij_0h_1I(n,kconf,ibconf1I,ksop_full,ndiff,Dw,&
       nbefore,socc,nsocc,knopen,knsp,averageii,confdim,iscratch,&
       hbuffer,ibuffer,nbuf,nrec,n_int_I,cfg)
    
    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Bra configuration counter
    integer(is), intent(inout) :: ibconf1I

    ! Index of the 1-hole configuration
    integer(is), intent(in)    :: n

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket reference space configuration
    integer(is), intent(in)    :: kconf
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(is), intent(in)    :: knopen,knsp
    
    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg
        
    ! Working arrays
    integer(ib)                :: bconf_int(n_int_I,2)
    integer(ib)                :: bsop_int(n_int_I,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Compute the R-1I matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I configurations generated by the current
    ! 1-hole configuration
    do ioff=cfg%off1I(n),cfg%off1I(n+1)-1
    
       ! Increment the 1I configuration counter
       ibconf1I=ibconf1I+1

       ! Bra 1I configuration in the internal MO space
       bconf_int=0_ib
       bconf_int=cfg%conf1I(1:n_int_I,:,ibconf1I)
       bsop_int=cfg%sop1I(1:n_int_I,:,ibconf1I)
       
       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(cfg%conf0h(:,:,kconf),bconf_int,&
            n_int_I)
    
       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle
    
       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_int,n_int_I)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
    
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(cfg%conf0h(:,:,kconf),bconf_int,&
            n_int_I,hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I,kconf,&
            cfg%sop1I(:,:,ibconf1I),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I,cfg%csfs0h,cfg%n1I+1,cfg%n0h+1,&
            averageii(ibconf1I+cfg%n0h),&
            averageii(kconf))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I,kconf,&
            cfg%csfs1I,cfg%csfs0h,cfg%n1I+1,cfg%n0h+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo

    return
    
  end subroutine save_hij_0h_1I

!######################################################################

  subroutine save_hij_0h_1E(n,kconf,ibconf1E,n_int_I,kconf_full,&
       ksop_full,ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,averageii,&
       confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Bra configuration counter
    integer(is), intent(inout) :: ibconf1E

    ! Index of the 1-hole configuration
    integer(is), intent(in)    :: n

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket reference space configuration
    integer(is), intent(in)    :: kconf
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(is), intent(in)    :: knopen,knsp
    
    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg
    
    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Compute the R-1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1E configurations generated by the current
    ! 1-hole configuration
    do ioff=cfg%off1E(n),cfg%off1E(n+1)-1
    
       ! Increment the 1E configuration counter
       ibconf1E=ibconf1E+1
    
       ! Bra 1E configuration in the full MO space
       bconf_full=0_ib
       bsop_full=0_ib
       bconf_full=cfg%conf1E(:,:,ibconf1E)
       bsop_full=cfg%sop1E(:,:,ibconf1E)
    
       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)
    
       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle
       
       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
    
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,&
            n_int,hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1E,kconf,&
            cfg%sop1E(:,:,ibconf1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1E,cfg%csfs0h,cfg%n1E+1,cfg%n0h+1,&
            averageii(ibconf1E+cfg%n0h+cfg%n1I+cfg%n2I),&
            averageii(kconf))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1E,kconf,&
            cfg%csfs1E,cfg%csfs0h,cfg%n1E+1,cfg%n0h+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo

    return
    
  end subroutine save_hij_0h_1E

!######################################################################

  subroutine save_hij_0h_2I(n,kconf,ibconf2I,n_int_I,ksop_full,&
       ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,averageii,confdim,&
       iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none
    
    ! Bra configuration counter
    integer(is), intent(inout) :: ibconf2I

    ! Index of the 2-hole configuration
    integer(is), intent(in)    :: n

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket reference space configuration
    integer(is), intent(in)    :: kconf
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg
    
    ! Working arrays
    integer(ib)                :: bconf_int(n_int_I,2)
    integer(ib)                :: bsop_int(n_int_I,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Compute the R-2I matrix elements
!----------------------------------------------------------------------
    ! Loop over 2I configurations generated by the current
    ! 2-hole configuration
    do ioff=cfg%off2I(n),cfg%off2I(n+1)-1

       ! Increment the 2I configuration counter
       ibconf2I=ibconf2I+1
    
       ! Bra 2I configuration in the internal MO space
       bconf_int=0_ib
       bconf_int=0_ib
       bconf_int=cfg%conf2I(1:n_int_I,:,ibconf2I)
       bsop_int=cfg%sop2I(1:n_int_I,:,ibconf2I)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(cfg%conf0h(:,:,kconf),bconf_int,n_int_I)
    
       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_int,n_int_I)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
    
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(cfg%conf0h(:,:,kconf),bconf_int,&
            n_int_I,hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf2I,kconf,&
            cfg%sop2I(:,:,ibconf2I),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs2I,cfg%csfs0h,cfg%n2I+1,cfg%n0h+1,&
            averageii(ibconf2I+cfg%n0h+cfg%n1I),&
            averageii(kconf))

       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf2I,kconf,&
            cfg%csfs2I,cfg%csfs0h,cfg%n2I+1,cfg%n0h+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_0h_2I

!######################################################################

  subroutine save_hij_0h_2E(n,kconf,ibconf2E,n_int_I,kconf_full,&
       ksop_full,ndiff,Dw,nbefore,socc,nsocc,knopen,knsp,averageii,&
       confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none
    
    ! Bra configuration counter
    integer(is), intent(inout) :: ibconf2E

    ! Index of the 2-hole configuration
    integer(is), intent(in)    :: n

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket reference space configuration
    integer(is), intent(in)    :: kconf
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(is), intent(in)    :: knopen,knsp
    
    ! Difference configuration information
    integer(is),intent(in)    :: ndiff
    integer(is),intent(in)    :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg
    
    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Compute the R-2E matrix elements
!----------------------------------------------------------------------
    ! Loop over 2E configurations generated by the current
    ! 2-hole configuration
    do ioff=cfg%off2E(n),cfg%off2E(n+1)-1

       ! Increment the 2E configuration counter
       ibconf2E=ibconf2E+1

       ! Bra 2E configuration in the full MO space
       bconf_full=0_ib
       bsop_full=0_ib
       bconf_full=cfg%conf2E(:,:,ibconf2E)
       bsop_full=cfg%sop2E(:,:,ibconf2E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)
       
       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle
       
       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
    
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,&
            n_int,hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf2E,kconf,&
            cfg%sop2E(:,:,ibconf2E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs2E,cfg%csfs0h,cfg%n2E+1,cfg%n0h+1,&
            averageii(ibconf2E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E),&
            averageii(kconf))

       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf2E,kconf,&
            cfg%csfs2E,cfg%csfs0h,cfg%n2E+1,cfg%n0h+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_0h_2E

!######################################################################

  subroutine save_hij_0h_1I1E(n,kconf,ibconf1I1E,n_int_I,&
       kconf_full,ksop_full,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,&
       ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Bra configuration counter
    integer(is), intent(inout) :: ibconf1I1E

    ! Index of the 2-hole configuration
    integer(is), intent(in)    :: n

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket reference space configuration
    integer(is), intent(in)    :: kconf
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)    :: ndiff
    integer(is),intent(in)    :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,nexci,bnopen,bnsp
    
!----------------------------------------------------------------------
! Compute the R-1I1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I1E configurations generated by the current
    ! 2-hole configuration
    do ioff=cfg%off1I1E(n),cfg%off1I1E(n+1)-1

       ! Increment the 1I1E configuration counter
       ibconf1I1E=ibconf1I1E+1
    
       ! Bra 1I1E configuration in the full MO space
       bconf_full=0_ib
       bsop_full=0_ib
       bconf_full=cfg%conf1I1E(:,:,ibconf1I1E)
       bsop_full=cfg%sop1I1E(:,:,ibconf1I1E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)
       
       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle       

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
    
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,&
            n_int,hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I1E,kconf,&
            cfg%sop1I1E(:,:,ibconf1I1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I1E,cfg%csfs0h,cfg%n1I1E+1,cfg%n0h+1,&
            averageii(ibconf1I1E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E+cfg%n2E),&
            averageii(kconf))
    
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I1E,kconf,&
            cfg%csfs1I1E,cfg%csfs0h,cfg%n1I1E+1,cfg%n0h+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
             
    enddo
       
    return
    
  end subroutine save_hij_0h_1I1E

!######################################################################

  subroutine save_hij_1I_1I(bn,ikconf1I,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 1I configuration
    integer(is), intent(in)    :: ikconf1I
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_int(n_int_I,2)
    integer(ib)                :: bsop_int(n_int_I,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1I
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 1I-1I matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1I(bn),cfg%off1I(bn+1)-1

       ! Bra 1I configuration counter
       ibconf1I=ioff

       ! Cycle if we are at a duplicate pair of configurations
       if (ibconf1I <= ikconf1I) cycle
       
       ! Bra 1I configuration in the internal MO space
       bconf_int=0_ib
       bconf_int=0_ib
       bconf_int=cfg%conf1I(1:n_int_I,:,ibconf1I)
       bsop_int=cfg%sop1I(1:n_int_I,:,ibconf1I)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_int,bconf_int,n_int_I)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_int,n_int_I)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_int,bconf_int,n_int_I,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I,ikconf1I,&
            cfg%sop1I(:,:,ibconf1I),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I,cfg%csfs1I,cfg%n1I+1,cfg%n1I+1,&
            averageii(ibconf1I+cfg%n0h),&
            averageii(ikconf1I+cfg%n0h))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I,ikconf1I,&
            cfg%csfs1I,cfg%csfs1I,cfg%n1I+1,cfg%n1I+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_1I_1I

!######################################################################

  subroutine save_hij_1I_1E(bn,ikconf1I,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 1I configuration
    integer(is), intent(in)    :: ikconf1I
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1E
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 1I-1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1E configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1E(bn),cfg%off1E(bn+1)-1

       ! Bra 1E configuration counter
       ibconf1E=ioff

       ! Bra 1E configuration
       bconf_full=cfg%conf1E(:,:,ibconf1E)
       bsop_full=cfg%sop1E(:,:,ibconf1E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1E,ikconf1I,&
            cfg%sop1E(:,:,ibconf1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1E,cfg%csfs1I,cfg%n1E+1,cfg%n1I+1,&
            averageii(ibconf1E+cfg%n0h+cfg%n1I+cfg%n2I),&
            averageii(ikconf1I+cfg%n0h))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1E,ikconf1I,&
            cfg%csfs1E,cfg%csfs1I,cfg%n1E+1,cfg%n1I+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_1I_1E

!######################################################################

  subroutine save_hij_1E_1E(nac1,hlist1,plist1,hpdim,bn,ikconf1E,&
       kconf_full,ksop_full,n_int_I,ndiff,Dw,nbefore,socc,&
       nsocc,knopen,knsp,averageii,confdim,iscratch,&
       hbuffer,ibuffer,nbuf,nrec,cfg)
    
    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Creation and annihilation operators linking the ket 1E
    ! and bra 1-hole configurations
    integer(is)                :: nac1
    integer(is)                :: hpdim
    integer(is)                :: hlist1(hpdim),plist1(hpdim)
    
    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 1I configuration
    integer(is), intent(in)    :: ikconf1E
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1E
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 1E-1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1E configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1E(bn),cfg%off1E(bn+1)-1

       ! Bra 1E configuration counter
       ibconf1E=ioff

       ! Cycle if we are at a duplicate pair of configurations
       if (ibconf1E <= ikconf1E) cycle
       
       ! Shortcut: if the two configurations differ by two excitations
       ! within the internal space, they cannot be interacting if
       ! the external MOs are not identical
       if (cfg%a1E(ikconf1E) /= cfg%a1E(ibconf1E) .and. nac1 == 4) cycle
       
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       if (nac1 == 0) then
          ! Same bra and ket 1-hole configurations
          nexci=1
          hlist(1)=cfg%a1E(ikconf1E)
          plist(1)=cfg%a1E(ibconf1E)
       else if (nac1 == 2) then
          ! Bra and ket 1-hole configurations linked by a single
          ! excitation
          if (cfg%a1E(ikconf1E) == cfg%a1E(ibconf1E)) then
             ! Same external MOs
             nexci=1
             hlist(1)=hlist1(1)
             plist(1)=plist1(1)
          else
             ! Different external MOs
             nexci=2
             hlist(1)=hlist1(1)
             plist(1)=plist1(1)
             hlist(2)=cfg%a1E(ikconf1E)
             plist(2)=cfg%a1E(ibconf1E)
          endif
       else if (nac1 == 4) then
          ! Bra and ket 1-hole configurations linked by a double
          ! excitation -> same external creation operator for both
          ! the bra and ket
          nexci=2
          hlist(1:2)=hlist1(1:2)
          plist(1:2)=plist1(1:2)
       endif

       ! Bra 1E configuration
       bconf_full=cfg%conf1E(:,:,ibconf1E)
       bsop_full=cfg%sop1E(:,:,ibconf1E)

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1E,ikconf1E,&
            cfg%sop1E(:,:,ibconf1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1E,cfg%csfs1E,cfg%n1E+1,cfg%n1E+1,&
            averageii(ibconf1E+cfg%n0h+cfg%n1I+cfg%n2I),&
            averageii(ikconf1E+cfg%n0h+cfg%n1I+cfg%n2I))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1E,ikconf1E,&
            cfg%csfs1E,cfg%csfs1E,cfg%n1E+1,cfg%n1E+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
    
    return
    
  end subroutine save_hij_1E_1E

!######################################################################

   subroutine save_hij_2I_1I(bn,ikconf2I,kconf_full,ksop_full,&
        kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
        knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 2I configuration
    integer(is), intent(in)    :: ikconf2I
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_int(n_int_I,2)
    integer(ib)                :: bsop_int(n_int_I,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1I
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 2I-1I matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1I(bn),cfg%off1I(bn+1)-1

       ! Bra 1I configuration counter
       ibconf1I=ioff

       ! Bra 1I configuration in the internal MO space
       bconf_int=0_ib
       bconf_int=0_ib
       bconf_int=cfg%conf1I(1:n_int_I,:,ibconf1I)
       bsop_int=cfg%sop1I(1:n_int_I,:,ibconf1I)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_int,bconf_int,n_int_I)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_int,n_int_I)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_int,bconf_int,n_int_I,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I,ikconf2I,&
            cfg%sop1I(:,:,ibconf1I),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I,cfg%csfs2I,cfg%n1I+1,cfg%n2I+1,&
            averageii(ibconf1I+cfg%n0h),&
            averageii(ikconf2I+cfg%n0h+cfg%n1I))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I,ikconf2I,&
            cfg%csfs1I,cfg%csfs2I,cfg%n1I+1,cfg%n2I+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return

  end subroutine save_hij_2I_1I

!######################################################################

  subroutine save_hij_2I_1E(bn,ikconf2I,kconf_full,ksop_full,&
        kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
        knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 2I configuration
    integer(is), intent(in)    :: ikconf2I
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1E
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 2I-1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1E configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1E(bn),cfg%off1E(bn+1)-1

       ! Bra 1E configuration counter
       ibconf1E=ioff

       ! Bra 1E configuration in the full MO space
       bconf_full=cfg%conf1E(:,:,ibconf1E)
       bsop_full=cfg%sop1E(:,:,ibconf1E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1E,ikconf2I,&
            cfg%sop1E(:,:,ibconf1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1E,cfg%csfs2I,cfg%n1E+1,cfg%n2I+1,&
            averageii(ibconf1E+cfg%n0h+cfg%n1I+cfg%n2I),&
            averageii(ikconf2I+cfg%n0h+cfg%n1I))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1E,ikconf2I,&
            cfg%csfs1E,cfg%csfs2I,cfg%n1E+1,cfg%n2I+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return

  end subroutine save_hij_2I_1E

!######################################################################

  subroutine save_hij_2E_1I(bn,ikconf2E,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 2E configuration
    integer(is), intent(in)    :: ikconf2E
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)

    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1I
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 2E-1I matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1I(bn),cfg%off1I(bn+1)-1

       ! Bra 1I configuration counter
       ibconf1I=ioff

       ! Bra 1I configuration in the full MO space
       bconf_full=cfg%conf1I(:,:,ibconf1I)
       bsop_full=cfg%sop1I(:,:,ibconf1I)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I,ikconf2E,&
            cfg%sop1I(:,:,ibconf1I),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I,cfg%csfs2E,cfg%n1I+1,cfg%n2E+1,&
            averageii(ibconf1I+cfg%n0h),&
            averageii(ikconf2E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I,ikconf2E,&
            cfg%csfs1I,cfg%csfs2E,cfg%n1I+1,cfg%n2E+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_2E_1I

!######################################################################

  subroutine save_hij_2E_1E(bn,ikconf2E,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 2E configuration
    integer(is), intent(in)    :: ikconf2E
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)

    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1E
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 2E-1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1E configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1E(bn),cfg%off1E(bn+1)-1

       ! Bra 1E configuration counter
       ibconf1E=ioff

       ! Bra 1E configuration in the full MO space
       bconf_full=cfg%conf1E(:,:,ibconf1E)
       bsop_full=cfg%sop1E(:,:,ibconf1E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1E,ikconf2E,&
            cfg%sop1E(:,:,ibconf1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1E,cfg%csfs2E,cfg%n1E+1,cfg%n2E+1,&
            averageii(ibconf1E+cfg%n0h+cfg%n1I+cfg%n2I),&
            averageii(ikconf2E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1E,ikconf2E,&
            cfg%csfs1E,cfg%csfs2E,cfg%n1E+1,cfg%n2E+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return

  end subroutine save_hij_2E_1E

!######################################################################

  subroutine save_hij_1I1E_1I(bn,ikconf1I1E,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 1I1E configuration
    integer(is), intent(in)    :: ikconf1I1E
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)

    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1I
    integer(is)                :: nexci,bnopen,bnsp 

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 1I1E-1I matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1I(bn),cfg%off1I(bn+1)-1

       ! Bra 1I configuration counter
       ibconf1I=ioff

       ! Bra 1I configuration in the full MO space
       bconf_full=cfg%conf1I(:,:,ibconf1I)
       bsop_full=cfg%sop1I(:,:,ibconf1I)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I,ikconf1I1E,&
            cfg%sop1I(:,:,ibconf1I),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I,cfg%csfs1I1E,cfg%n1I+1,cfg%n1I1E+1,&
            averageii(ibconf1I+cfg%n0h),&
            averageii(ikconf1I1E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E+cfg%n2E))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I,ikconf1I1E,&
            cfg%csfs1I,cfg%csfs1I1E,cfg%n1I+1,cfg%n1I1E+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
    
    return
    
  end subroutine save_hij_1I1E_1I

!######################################################################

  subroutine save_hij_1I1E_1E(bn,ikconf1I1E,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 1-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I

    ! Ket 1I1E configuration
    integer(is), intent(in)    :: ikconf1I1E
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)

    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1E
    integer(is)                :: nexci,bnopen,bnsp 

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 1I1E-1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1E configurations generated by the bra 1-hole
    ! configuration
    do ioff=cfg%off1E(bn),cfg%off1E(bn+1)-1

       ! Bra 1E configuration counter
       ibconf1E=ioff

       ! Bra 1E configuration in the full MO space
       bconf_full=cfg%conf1E(:,:,ibconf1E)
       bsop_full=cfg%sop1E(:,:,ibconf1E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)

       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1E,ikconf1I1E,&
            cfg%sop1E(:,:,ibconf1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1E,cfg%csfs1I1E,cfg%n1E+1,cfg%n1I1E+1,&
            averageii(ibconf1E+cfg%n0h+cfg%n1I+cfg%n2I),&
            averageii(ikconf1I1E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E+cfg%n2E))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1E,ikconf1I1E,&
            cfg%csfs1E,cfg%csfs1I1E,cfg%n1E+1,cfg%n1I1E+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_1I1E_1E

!######################################################################

  subroutine save_hij_2I_2I(bn,ikconf2I,kconf_full,ksop_full,&
        kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
        knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 2-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I
    
    ! Ket 2I configuration
    integer(is), intent(in)    :: ikconf2I
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_int(n_int_I,2)
    integer(ib)                :: bsop_int(n_int_I,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf2I
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 2I-2I matrix elements
!----------------------------------------------------------------------
    ! Loop over 2I configurations generated by the bra 2-hole
    ! configuration
    do ioff=cfg%off2I(bn),cfg%off2I(bn+1)-1

       ! Bra 2I configuration counter
       ibconf2I=ioff

       ! Cycle if we are at an on-diagonal element
       !if (ibconf2I == ikconf2I) cycle
       if (ibconf2I <= ikconf2I) cycle
       
       ! Bra 2I configuration in the internal MO space
       bconf_int=0_ib
       bconf_int=0_ib
       bconf_int=cfg%conf2I(1:n_int_I,:,ibconf2I)
       bsop_int=cfg%sop2I(1:n_int_I,:,ibconf2I)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_int,bconf_int,n_int_I)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_int,n_int_I)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
       
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_int,bconf_int,n_int_I,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf2I,ikconf2I,&
            cfg%sop2I(:,:,ibconf2I),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs2I,cfg%csfs2I,cfg%n2I+1,cfg%n2I+1,&
            averageii(ibconf2I+cfg%n0h+cfg%n1I),&
            averageii(ikconf2I+cfg%n0h+cfg%n1I))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf2I,ikconf2I,&
            cfg%csfs2I,cfg%csfs2I,cfg%n2I+1,cfg%n2I+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_2I_2I

!######################################################################

subroutine save_hij_2I_2E(nac1,bn,ikconf2I,kconf_full,ksop_full,&
        kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
        knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Number of creation/annihilation operators linking the ket 2I
    ! and bra 2-hole configurations
    integer(is), intent(in)    :: nac1
    
    ! Index of the bra 2-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I
    
    ! Ket 2I configuration
    integer(is), intent(in)    :: ikconf2I
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf2E
    integer(is)                :: nexci,bnopen,bnsp
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 2I-2E matrix elements
!----------------------------------------------------------------------
    ! Loop over 2E configurations generated by the bra 2-hole
    ! configuration
    do ioff=cfg%off2E(bn),cfg%off2E(bn+1)-1

       ! Bra 2E configuration counter
       ibconf2E=ioff

       ! Bra 2E configuration in the full MO space
       bconf_full=cfg%conf2E(:,:,ibconf2E)
       bsop_full=cfg%sop2E(:,:,ibconf2E)

       ! Excitation degree between the two configurations
       nexci=(nac1/2+1)
              
       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
       
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf2E,ikconf2I,&
            cfg%sop2E(:,:,ibconf2E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs2E,cfg%csfs2I,cfg%n2E+1,cfg%n2I+1,&
            averageii(ibconf2E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E),&
            averageii(ikconf2I+cfg%n0h+cfg%n1I))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf2E,ikconf2I,&
            cfg%csfs2E,cfg%csfs2I,cfg%n2E+1,cfg%n2I+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_2I_2E

!######################################################################

  subroutine save_hij_2I_1I1E(bn,ikconf2I,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 2-hole configuration
    integer(is), intent(in)    :: bn
    
    ! Dimensions
    integer(is), intent(in)    :: n_int_I
    
    ! Ket 2I configuration
    integer(is), intent(in)    :: ikconf2I
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1I1E
    integer(is)                :: nexci,bnopen,bnsp
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 2I-1I1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I1E configurations generated by the bra 2-hole
    ! configuration
    do ioff=cfg%off1I1E(bn),cfg%off1I1E(bn+1)-1

       ! Bra 1I1E configuration counter
       ibconf1I1E=ioff

       ! Bra 1I1E configuration in the full MO space
       bconf_full=cfg%conf1I1E(:,:,ibconf1I1E)
       bsop_full=cfg%sop1I1E(:,:,ibconf1I1E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
       
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I1E,ikconf2I,&
            cfg%sop1I1E(:,:,ibconf1I1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I1E,cfg%csfs2I,cfg%n1I1E+1,cfg%n2I+1,&
            averageii(ibconf1I1E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E+cfg%n2E),&
            averageii(ikconf2I+cfg%n0h+cfg%n1I))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I1E,ikconf2I,&
            cfg%csfs1I1E,cfg%csfs2I,cfg%n1I1E+1,cfg%n2I+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
              
    return
    
  end subroutine save_hij_2I_1I1E

!######################################################################

  subroutine save_hij_2E_2E(nac1,hlist1,plist1,hpdim,bn,ikconf2E,&
       kconf_full,ksop_full,kconf_int,ksop_int,n_int_I,ndiff,Dw,&
       nbefore,socc,nsocc,knopen,knsp,averageii,confdim,iscratch,&
       hbuffer,ibuffer,nbuf,nrec,cfg)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Creation and annihilation operators linking the ket 1E
    ! and bra 1-hole configurations
    integer(is)                :: nac1
    integer(is)                :: hpdim
    integer(is)                :: hlist1(hpdim),plist1(hpdim)
    
    ! Index of the bra 2-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I
    
    ! Ket 2E configuration
    integer(is), intent(in)    :: ikconf2E
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf2E
    integer(is)                :: nexci,bnopen,bnsp

    
    integer(is) :: j,k,m,n,nexci1,tmp,counter

    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0
    
!----------------------------------------------------------------------
! Compute the 2E-2E matrix elements
!----------------------------------------------------------------------
    ! Loop over 2E configurations generated by the bra 2-hole
    ! configuration
    do ioff=cfg%off2E(bn),cfg%off2E(bn+1)-1

       ! Bra 2E configuration counter
       ibconf2E=ioff

       ! Cycle if we are at a duplicate pair of configurations
       if (ibconf2E <= ikconf2E) cycle

       ! Bra 2E configuration in the full MO space
       bconf_full=cfg%conf2E(:,:,ibconf2E)
       bsop_full=cfg%sop2E(:,:,ibconf2E)
       
       ! Shortcut: if the two configurations differ by two excitations
       ! within the internal space, they cannot be interacting if
       ! the external MOs are not identical
       if (nac1 == 4) then
          if (cfg%a2E(1,ikconf2E) /= cfg%a2E(1,ibconf2E) &
               .or. cfg%a2E(2,ikconf2E) /= cfg%a2E(2,ibconf2E)) cycle
       endif
       
       ! No. excitations within the internal space 
       nexci1=nac1/2

       ! Ket creation operator indices
       j=cfg%a2E(1,ikconf2E)
       k=cfg%a2E(2,ikconf2E)
       
       ! Bra creation operator indices
       m=cfg%a2E(1,ibconf2E)
       n=cfg%a2E(2,ibconf2E)
       
       ! Remove creation operator indices that appear in both
       ! the bra and ket
       nexci=nexci1+2
       if (j == m) then
          nexci=nexci-1
          j=0
          m=0
       endif
       if (j == n .and. j /= 0) then
          nexci=nexci-1
          j=0
          n=0
       endif
       if (k == m .and. k /= 0) then
          nexci=nexci-1
          k=0
          m=0
       endif
       if (k == n .and. k /= 0 .and. n /= 0) then
          nexci=nexci-1
          k=0
          n=0
       endif
       
       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle
       
       ! Hole indices
       hlist(1:nexci1)=hlist1(1:nexci1)
       counter=nexci1
       if (j /= 0) then
          counter=counter+1
          hlist(counter)=j
       endif
       if (k /= 0) then
          counter=counter+1
          hlist(counter)=k
       endif
       
       ! Particle indices
       plist(1:nexci1)=plist1(1:nexci1)
       counter=nexci1
       if (m /= 0) then
          counter=counter+1
          plist(counter)=m
       endif
       if (n /= 0) then
          counter=counter+1
          plist(counter)=n
       endif
       
       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
       
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
       
       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf2E,ikconf2E,&
            cfg%sop2E(:,:,ibconf2E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs2E,cfg%csfs2E,cfg%n2E+1,cfg%n2E+1,&
            averageii(ibconf2E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E),&
            averageii(ikconf2E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf2E,ikconf2E,&
            cfg%csfs2E,cfg%csfs2E,cfg%n2E+1,cfg%n2E+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_2E_2E

!######################################################################

  subroutine save_hij_2E_1I1E(bn,ikconf2E,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)
    
    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 2-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I
    
    ! Ket 2E configuration
    integer(is), intent(in)    :: ikconf2E
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1I1E
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 2E-1I1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I1E configurations generated by the bra 2-hole
    ! configuration
    do ioff=cfg%off1I1E(bn),cfg%off1I1E(bn+1)-1

       ! Bra 1I1E configuration counter
       ibconf1I1E=ioff
       
       ! Bra 1I1E configuration in the full MO space
       bconf_full=cfg%conf1I1E(:,:,ibconf1I1E)
       bsop_full=cfg%sop1I1E(:,:,ibconf1I1E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
       
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I1E,ikconf2E,&
            cfg%sop1I1E(:,:,ibconf1I1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I1E,cfg%csfs2E,cfg%n1I1E+1,cfg%n2E+1,&
            averageii(ibconf1I1E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E+cfg%n2E),&
            averageii(ikconf2E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I1E,ikconf2E,&
            cfg%csfs1I1E,cfg%csfs2E,cfg%n1I1E+1,cfg%n2E+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_2E_1I1E

!######################################################################

  subroutine save_hij_1I1E_1I1E(bn,ikconf1I1E,kconf_full,ksop_full,&
       kconf_int,ksop_int,n_int_I,ndiff,Dw,nbefore,socc,nsocc,knopen,&
       knsp,averageii,confdim,iscratch,hbuffer,ibuffer,nbuf,nrec,cfg)
    
    use constants
    use bitglobal
    use conftype
    use mrciutils
    use hbuild_mrci
    use mrci_integrals
    use dftmrci
    
    implicit none

    ! Index of the bra 2-hole configuration
    integer(is), intent(in)    :: bn

    ! Dimensions
    integer(is), intent(in)    :: n_int_I
    
    ! Ket 1I1E configuration
    integer(is), intent(in)    :: ikconf1I1E
    integer(ib), intent(in)    :: kconf_full(n_int,2)
    integer(ib), intent(in)    :: ksop_full(n_int,2)
    integer(ib), intent(in)    :: kconf_int(n_int_I,2)
    integer(ib), intent(in)    :: ksop_int(n_int_I,2)
    integer(is), intent(in)    :: knopen,knsp

    ! Difference configuration information
    integer(is),intent(in)     :: ndiff
    integer(is),intent(in)     :: Dw(nmo,2)
    
    ! Number of open shells preceding each MO
    integer(is), intent(in)    :: nbefore(nmo)

    ! Indices of the singly-occupied ket MOs
    integer(is), intent(in)    :: socc(nmo)
    integer(is), intent(in)    :: nsocc

    ! Spin-coupling averaged on-diagonal Hamiltonian
    ! matrix element values
    integer(is), intent(in)    :: confdim
    real(dp), intent(in)       :: averageii(confdim)

    ! Hamiltonian matrix scratch file
    integer(is), intent(in)    :: iscratch

    ! Buffer
    integer(is), intent(inout) :: nrec,nbuf
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! MRCI configuration derived type
    type(mrcfg), intent(in)    :: cfg

    ! Working arrays
    integer(ib)                :: bconf_full(n_int,2)
    integer(ib)                :: bsop_full(n_int,2)
    integer(is), parameter     :: maxexci=2
    integer(is)                :: hlist(maxexci),plist(maxexci)

    ! Everything else
    integer(is)                :: ioff,ibconf1I1E
    integer(is)                :: nexci,bnopen,bnsp

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    !allocate(harr2(ncsfs(nomax),ncsfs(nomax)))
    !harr2=0.0d0

!----------------------------------------------------------------------
! Compute the 1I1E-1I1E matrix elements
!----------------------------------------------------------------------
    ! Loop over 1I1E configurations generated by the bra 2-hole
    ! configuration
    do ioff=cfg%off1I1E(bn),cfg%off1I1E(bn+1)-1

       ! Bra 1I1E configuration counter
       ibconf1I1E=ioff

       ! Cycle if we are at a duplicate pair of configurations
       if (ibconf1I1E <= ikconf1I1E) cycle
       
       ! Bra 1I1E configuration in the full MO space
       bconf_full=cfg%conf1I1E(:,:,ibconf1I1E)
       bsop_full=cfg%sop1I1E(:,:,ibconf1I1E)

       ! Compute the excitation degree between the two
       ! configurations
       nexci=exc_degree_conf(kconf_full,bconf_full,n_int)

       ! Cycle if the excitation degree is greater than 2
       if (nexci > 2) cycle

       ! Number of open shells in the bra configuration
       bnopen=sop_nopen(bsop_full,n_int)
    
       ! Number of bra CSFs
       bnsp=ncsfs(bnopen)
       
       ! Get the indices of the MOs involved in the excitation
       hlist=0
       plist=0
       call get_exci_indices(kconf_full,bconf_full,n_int,&
            hlist(1:nexci),plist(1:nexci),nexci)

       ! Compute the matrix elements between the CSFs generated
       ! by the bra and ket configurations
       call hij_mrci(harr2,ncsfs(nomax),nexci,&
            ibconf1I1E,ikconf1I1E,&
            cfg%sop1I1E(:,:,ibconf1I1E),ksop_full,&
            bnsp,knsp,bnopen,knopen,hlist,plist,cfg%m2c,&
            socc,nsocc,nbefore,Dw,ndiff,&
            cfg%csfs1I1E,cfg%csfs1I1E,cfg%n1I1E+1,cfg%n1I1E+1,&
            averageii(ibconf1I1E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E+cfg%n2E),&
            averageii(ikconf1I1E+cfg%n0h+cfg%n1I+cfg%n2I+cfg%n1E+cfg%n2E))
       
       ! Save the above-threshold matrix elements
       call save_above_threshold(ibconf1I1E,ikconf1I1E,&
            cfg%csfs1I1E,cfg%csfs1I1E,cfg%n1I1E+1,cfg%n1I1E+1,&
            bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)
       
    enddo
       
    return
    
  end subroutine save_hij_1I1E_1I1E
    
!######################################################################
! save_above_threshold: buffered saving of the above-threshold
!                       off-diagonal Hamiltonian matrix elements to
!                       disk
!######################################################################
  subroutine save_above_threshold(bconf,kconf,bcsfs,kcsfs,bdim,kdim,&
       bnsp,knsp,iscratch,hbuffer,ibuffer,nbuf,nrec)

    use constants
    use bitglobal
    
    implicit none

    ! Configuration indices
    integer(is), intent(in)    :: bconf,kconf
    
    ! CSF offsets
    integer(is), intent(in)    :: kdim,bdim
    integer(is), intent(in)    :: bcsfs(bdim),kcsfs(kdim)

    ! Numbers of bra and ket CSFs
    integer(is), intent(in)    :: bnsp,knsp

    ! Buffered I/O variables
    integer(is), intent(in)    :: iscratch
    integer(is), intent(inout) :: nbuf,nrec
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    real(dp), intent(inout)    :: hbuffer(bufsize)

    ! Everything else
    integer(is)                :: bomega,komega,ikcsf,ibcsf

    ! Loop over ket CSFs
    komega=0
    do ikcsf=kcsfs(kconf),kcsfs(kconf+1)-1
       komega=komega+1

       ! Loop over bra CSFs
       bomega=0
       do ibcsf=bcsfs(bconf),bcsfs(bconf+1)-1
          bomega=bomega+1
          
          ! Save the matrix element if it is above threshold
          if (abs(harr2(bomega,komega)) > epshij) then
             nbuf=nbuf+1
             ibuffer(1,nbuf)=ibcsf
             ibuffer(2,nbuf)=ikcsf
             hbuffer(nbuf)=harr2(bomega,komega)
             if (nbuf == bufsize) call dump_buffer(iscratch,&
                  hbuffer,ibuffer,nbuf,nrec)
          endif
          
       enddo
    enddo
    
    return
    
  end subroutine save_above_threshold
  
!######################################################################
! dump_buffer: dumps the Hamiltonian matrix element buffer to disk and
!              increments/resets the associated counters
!######################################################################
  subroutine dump_buffer(iscratch,hbuffer,ibuffer,nbuf,nrec)

    use constants
    use bitglobal
    
    implicit none

    integer(is), intent(in)    :: iscratch
    integer(is), intent(inout) :: nbuf,nrec
    integer(is), intent(in)    :: ibuffer(2,bufsize)
    real(dp), intent(in)       :: hbuffer(bufsize)

    !
    ! Write the buffers to disk
    !
    write(iscratch) hbuffer,ibuffer,nbuf

    !
    ! Reset/increment the counters
    !
    nbuf=0
    nrec=nrec+1
    
    return
    
  end subroutine dump_buffer
    
!######################################################################
  
end module hij_disk
