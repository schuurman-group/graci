!**********************************************************************
! Routines for the generation of hole configurations
!**********************************************************************
module holeconfs
  
  implicit none
  
contains
    
!######################################################################
! generate_1hole_confs: generates all possible 1-hole configurations
!                       from a given set of reference space
!                       configurations
!######################################################################
  subroutine generate_1hole_confs(cfgM,icvs,E0max)
    
    use constants
    use bitglobal
    use conftype
        
    implicit none
    
    ! MRCI configurations
    type(mrcfg), intent(inout) :: cfgM

    ! CVS-MRCI: core MOs
    integer(is), intent(in)    :: icvs(nmo)
    logical                    :: lcvs

    ! Energy of the highest-lying reference space state of interest
    real(dp), intent(in)       :: E0max
    
    ! Everything else
    integer(is)                :: modus
    
!----------------------------------------------------------------------
! Is this a CVS-MRCI calculation
!----------------------------------------------------------------------
    if (sum(icvs) > 0) then
       lcvs=.true.
    else
       lcvs=.false.
    endif
    
!----------------------------------------------------------------------
! First pass: determine the no. 1-hole configurations
!----------------------------------------------------------------------
    modus=0
    call builder_1hole(modus,cfgM,icvs,lcvs,E0max)

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(cfgM%conf1h(cfgM%n_int_I,2,cfgM%n1h))
    cfgM%conf1h=0_ib

    allocate(cfgM%off1h(cfgM%nR+1))
    cfgM%off1h=0
    
!----------------------------------------------------------------------
! Second pass: fill in the 1-hole configuration and offset arrays
!----------------------------------------------------------------------
    modus=1
    call builder_1hole(modus,cfgM,icvs,lcvs,E0max)
    
    return
    
  end subroutine generate_1hole_confs

!######################################################################
! builder_1hole: performs all the heavy lifting involved in the
!                generation of the 1-hole configurations
!######################################################################
  subroutine builder_1hole(modus,cfgM,icvs,lcvs,E0max)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use dethash
    use hparam
    
    implicit none

    ! Mode of operation: modus=0 <-> determine the number of hole
    !                                configurations
    !                    modus=1 <-> build all of the hole
    !                                configurations
    integer(is), intent(in)    :: modus
    
    ! MRCI configurations
    type(mrcfg), intent(inout) :: cfgM

    ! CVS-MRCI: core MOs
    integer(is), intent(in)    :: icvs(nmo)
    logical, intent(in)        :: lcvs

    ! Energy of the highest-lying reference space state of interest
    real(dp), intent(in)       :: E0max
    
    ! Orbital classes
    integer(is)                :: socc(nmo),docc(nmo),unocc(nmo)
    integer(is)                :: nopen,nsocc,ndocc,nunocc
    
    ! Hash table
    type(dhtbl)                :: h
    integer(is)                :: initial_size
    integer(ib)                :: key(n_int,2)
    integer(ib), allocatable   :: keyI(:,:)

    ! Number of 1-hole configurations generated by each
    ! reference configuration
    integer(is), allocatable   :: ngen(:)
    
    ! Everything else
    integer(is)                :: i,n,imo,i1
    integer(is)                :: n_int_I,n1h 
    integer(is)                :: counter

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    n_int_I=cfgM%n_int_I
    allocate(keyI(n_int_I,2))
    allocate(ngen(cfgM%nR))
    
!----------------------------------------------------------------------
! Initialisation
!----------------------------------------------------------------------
    counter=0
    ngen=0
    
!----------------------------------------------------------------------
! Initialise the hash table
!----------------------------------------------------------------------
    initial_size=cfgM%nR*nel/2
    call h%initialise_table(initial_size)
    
!----------------------------------------------------------------------
! Generate the 1-hole configurations
!----------------------------------------------------------------------
    ! Loop over reference configurations
    do n=1,cfgM%nR
       
       ! Get the lists of singly- and doubly-occupied MOs
       ! for the current reference configuration
       call sop_socc_list(cfgM%sopR(:,:,n),n_int_I,socc,nmo,nsocc)
       call sop_docc_list(cfgM%sopR(:,:,n),n_int_I,docc,nmo,ndocc)
       
       ! 1-hole configurations generated from annihilation of
       ! electrons in singly-occupied MOs
       do imo=1,nsocc
          
          ! MO index
          i1=socc(imo)

          ! Cycle if this 1-hole configuration cannot possibly
          ! generate DFT/MRCI confs satisfying the energy selection
          ! criterion
          if (ldftmrci) then
             if (iocc0(cfgM%m2c(i1)) /= 0 &
                  .and. abs(moen(cfgM%m2c(i1))) > E0max+desel) cycle
          endif
             
          ! Cycle if this is a CVS-MRCI calculation and we are creating
          ! a hole in a flagged core MO
          if (lcvs .and. icvs(cfgM%m2c(i1)) == 1) cycle
          
          ! Annihilate an electron in imo'th singly-occupied MO
          keyI=annihilate_electron(cfgM%confR(:,:,n),n_int_I,i1)
          key=0_ib
          key(1:n_int_I,:)=keyI
          
          ! Insert the conf into the hash table
          call h%insert_key(key)

          ! Do we have a new 1-hole configuration?
          if (counter < h%n_keys_stored) then
             counter=counter+1
             ngen(n)=ngen(n)+1
             if (modus == 1) cfgM%conf1h(:,:,counter)=keyI
          endif
          
       enddo
       
       ! 1-hole configurations generated from annihilation of
       ! electrons in doubly-occupied MOs
       do imo=1,ndocc
          
          ! MO index
          i1=docc(imo)

          ! Cycle if this 1-hole configuration cannot possibly
          ! generate DFT/MRCI confs satisfying the energy selection
          ! criterion
          if (ldftmrci) then
             if (iocc0(cfgM%m2c(i1)) /= 0 &
                  .and. abs(moen(cfgM%m2c(i1))) > E0max+desel) cycle
          endif
             
          ! Cycle if this is a CVS-MRCI calculation and we are creating
          ! a hole in a flagged core MO
          if (lcvs .and. icvs(cfgM%m2c(i1)) == 1) cycle
          
          ! Annihilate an electron in imo'th singly-occupied MO
          keyI=annihilate_electron(cfgM%confR(:,:,n),n_int_I,i1)
          key=0_ib
          key(1:n_int_I,:)=keyI
          
          ! Insert the conf into the hash table
          call h%insert_key(key)

          ! Do we have a new 1-hole configuration?
          if (counter < h%n_keys_stored) then
             counter=counter+1
             ngen(n)=ngen(n)+1
             if (modus == 1) cfgM%conf1h(:,:,counter)=keyI
          endif
          
       enddo
       
    enddo
    
!----------------------------------------------------------------------
! Total number of keys stored in the hash table
!----------------------------------------------------------------------
    n1h=h%n_keys_stored

!----------------------------------------------------------------------
! If we are just determining the number of hole configurations, then
! save this number
!----------------------------------------------------------------------
    if (modus == 0) cfgM%n1h=n1h

!----------------------------------------------------------------------
! Fill in the offset array
!----------------------------------------------------------------------
    if (modus == 1) then
       cfgM%off1h(1)=1
       do n=2,cfgM%nR+1
          cfgM%off1h(n)=cfgM%off1h(n-1)+ngen(n-1)
       enddo
    endif
    
!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    call h%delete_table
    deallocate(keyI)
    deallocate(ngen)
    
    return
    
  end subroutine builder_1hole
    
!######################################################################
! generate_2hole_confs: generates all possible 2-hole configurations
!                       from a given set of 1-hole configurations
!######################################################################
  subroutine generate_2hole_confs(cfgM,icvs,E0max)

    use constants
    use bitglobal
    use conftype
    
    implicit none

    ! MRCI configurations
    type(mrcfg), intent(inout) :: cfgM

    ! CVS-MRCI: core MOs
    integer(is), intent(in)    :: icvs(nmo)
    logical                    :: lcvs

    ! Energy of the highest-lying reference space state of interest
    real(dp), intent(in)       :: E0max
    
    ! Everything else
    integer(is)                :: modus

!----------------------------------------------------------------------
! Is this a CVS-MRCI calculation
!----------------------------------------------------------------------
    if (sum(icvs) > 0) then
       lcvs=.true.
    else
       lcvs=.false.
    endif
    
!----------------------------------------------------------------------
! First pass: determine the no. 2-hole configurations
!----------------------------------------------------------------------
    modus=0
    call builder_2hole(modus,cfgM,icvs,lcvs,E0max)

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(cfgM%conf2h(cfgM%n_int_I,2,cfgM%n2h))
    cfgM%conf2h=0_ib

    allocate(cfgM%off2h(cfgM%nR+1))
    cfgM%off2h=0
    
!----------------------------------------------------------------------
! Second pass: fill in the 2-hole configuration and offset arrays
!----------------------------------------------------------------------
    modus=1
    call builder_2hole(modus,cfgM,icvs,lcvs,E0max)

    return
    
  end subroutine generate_2hole_confs

!######################################################################
! builder_2hole: performs all the heavy lifting involved in the
!                generation of the 2-hole configurations
!######################################################################
  subroutine builder_2hole(modus,cfgM,icvs,lcvs,E0max)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use dethash
    use hparam
    
    implicit none

    ! Mode of operation: modus=0 <-> determine the number of hole
    !                                configurations
    !                    modus=1 <-> build all of the hole
    !                                configurations
    integer(is), intent(in)    :: modus
    
    ! MRCI configurations
    type(mrcfg), intent(inout) :: cfgM

    ! CVS-MRCI: core MOs
    integer(is), intent(in)    :: icvs(nmo)
    logical, intent(in)        :: lcvs

    ! Energy of the highest-lying reference space state of interest
    real(dp), intent(in)       :: E0max
    
    ! 1-hole SOPs
    integer(ib), allocatable   :: sop1h(:,:,:)

    ! Orbital classes
    integer(is)                :: socc(nmo),docc(nmo),unocc(nmo)
    integer(is)                :: nopen,nsocc,ndocc,nunocc

    ! Difference configuration information
    integer(is)                :: Dw(nmo,2)
    integer(is)                :: ndiff
    
    ! Hash table
    type(dhtbl)                :: h
    integer(is)                :: initial_size
    integer(ib)                :: key(n_int,2)
    integer(ib), allocatable   :: keyI(:,:),confI(:,:)

    ! Number of 1-hole configurations generated by each
    ! reference configuration
    integer(is), allocatable   :: ngen(:)
    
    ! Everything else
    integer(is)                :: i,j,k,n,imo,i1,ioff
    integer(is)                :: n_int_I,n1h,n2h
    integer(is)                :: counter
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    n_int_I=cfgM%n_int_I
    n1h=cfgM%n1h
    
    allocate(sop1h(n_int_I,2,n1h))
    sop1h=0_ib

    allocate(keyI(n_int_I,2))
    keyI=0_ib

    allocate(confI(n_int_I,2))
    confI=0_ib

    allocate(ngen(cfgM%nR))
    ngen=0
    
!----------------------------------------------------------------------
! Generate the 1-hole SOPs
!----------------------------------------------------------------------    
    ! Loop over 1-hole configurations
    do i=1,n1h

       ! Generate the next 1-hole SOP
       confI=cfgM%conf1h(:,:,i)
       sop1h(:,:,i)=conf_to_sop(confI,n_int_I)

    enddo

!----------------------------------------------------------------------
! Initialise the hash table
!----------------------------------------------------------------------
    initial_size=n1h*(nel-1)/2
    call h%initialise_table(initial_size)
    
!----------------------------------------------------------------------
! Generate the 2-hole configurations
!----------------------------------------------------------------------
    ! Initialise the unique 2-hole configuration counter
    counter=0

    ! Loop over reference configurations
    i=0
    do n=1,cfgM%nR

       ! Loop over the 1-hole configurations generated by the current
       ! reference configuration
       do ioff=cfgM%off1h(n),cfgM%off1h(n+1)-1

          ! Increment the 1-hole conf counter
          i=i+1

          ! Get the lists of singly- and doubly-occupied MOs
          ! for the current 1-hole configuration
          call sop_socc_list(sop1h(:,:,i),n_int_I,socc,nmo,nsocc)
          call sop_docc_list(sop1h(:,:,i),n_int_I,docc,nmo,ndocc)

          ! 2-hole configurations generated from annihilation of
          ! electrons in singly-occupied MOs
          do imo=1,nsocc
          
             ! MO index
             i1=socc(imo)
             
             ! Cycle if this is a CVS-MRCI calculation and we are
             ! creating a hole in a flagged core MO
             if (lcvs .and. icvs(cfgM%m2c(i1)) == 1) cycle
             
             ! Annihilate an electron in imo'th singly-occupied MO
             keyI=annihilate_electron(cfgM%conf1h(:,:,i),n_int_I,i1)
             key=0_ib
             key(1:n_int_I,:)=keyI

             ! Cycle if this 2-hole configuration cannot possibly
             ! generate DFT/MRCI confs satisfying the energy selection
             ! criterion
             if (ldftmrci) then
                if (ehole(key,n_int,cfgM%m2c) > E0max+desel) cycle
             endif
             
             ! Insert the conf into the hash table
             call h%insert_key(key)

             ! Do we have a new 2-hole configuration?
             if (counter < h%n_keys_stored) then
                counter=counter+1
                ngen(n)=ngen(n)+1
                if (modus == 1) cfgM%conf2h(:,:,counter)=keyI
             endif
             
          enddo
          
          ! 2-hole configurations generated from annihilation of
          ! electrons in doubly-occupied MOs
          do imo=1,ndocc
             
             ! MO index
             i1=docc(imo)
             
             ! Cycle if this is a CVS-MRCI calculation and we are creating
             ! a hole in a flagged core MO
             if (lcvs .and. icvs(cfgM%m2c(i1)) == 1) cycle
             
             ! Annihilate an electron in imo'th singly-occupied MO
             keyI=annihilate_electron(cfgM%conf1h(:,:,i),n_int_I,i1)
             key=0_ib
             key(1:n_int_I,:)=keyI

             ! Cycle if this 2-hole configuration cannot possibly
             ! generate DFT/MRCI confs satisfying the energy selection
             ! criterion
             if (ldftmrci) then
                if (ehole(key,n_int,cfgM%m2c) > E0max+desel) cycle
             endif
             
             ! Insert the conf into the hash table
             call h%insert_key(key)

             ! Do we have a new 2-hole configuration?
             if (counter < h%n_keys_stored) then
                counter=counter+1
                ngen(n)=ngen(n)+1
                if (modus == 1) cfgM%conf2h(:,:,counter)=keyI
             endif
             
          enddo
          
       enddo

    enddo
    
!----------------------------------------------------------------------
! Total number of keys stored in the hash table
!----------------------------------------------------------------------
    n2h=h%n_keys_stored

!----------------------------------------------------------------------
! If we are just determining the number of hole configurations, then
! save this number
!----------------------------------------------------------------------
    if (modus == 0) cfgM%n2h=n2h

!----------------------------------------------------------------------
! Fill in the offset array
!----------------------------------------------------------------------
    if (modus == 1) then
       cfgM%off2h(1)=1
       do n=2,cfgM%nR+1
          cfgM%off2h(n)=cfgM%off2h(n-1)+ngen(n-1)
       enddo
    endif
    
!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    call h%delete_table
    deallocate(sop1h)
    deallocate(keyI)
    
    return
    
  end subroutine builder_2hole
  
!######################################################################
! generate_1hole_1I_confs: generates 1-hole configurations derived
!                          from the 2-hole configurations by the
!                          application of internal creation
!                          operators
!######################################################################
  subroutine generate_1hole_1I_confs(conf1h1I,n1h1I,indx1h1I,cfgM,&
       icvs,E0max)

    use constants
    use bitglobal
    use conftype
    use mrciutils
    use dethash
    use hparam
    use iomod
    
    implicit none

    ! 1H1I configurations
    integer(is), intent(out)   :: n1h1I
    integer(ib), allocatable   :: conf1h1I(:,:,:)
    integer(is), allocatable   :: indx1h1I(:,:)

    ! MRCI configurations
    type(mrcfg), intent(inout) :: cfgM

    ! CVS-MRCI: core MOs
    integer(is), intent(in)    :: icvs(nmo)
    logical                    :: lcvs

    ! Energy of the highest-lying reference space state of interest
    real(dp), intent(in)       :: E0max
    
    ! Orbital classes
    integer(is), allocatable   :: socc(:),docc(:),unocc(:)
    integer(is)                :: nopen,nsocc,ndocc,nunocc

    ! Difference configuration information
    integer(is)                :: Dw(nmo,2)
    integer(is)                :: ndiff
    
    ! Hash table
    type(dhtbl)                :: h
    integer(is)                :: initial_size
    integer(ib)                :: key(n_int,2)
    integer(ib), allocatable   :: keyI(:,:)
    
    ! Storage the 1H1I configurations
    integer(is)                :: nold,nbuf,nrec
    integer(is), allocatable   :: ibuffer(:,:)
    integer(ib), allocatable   :: cbuffer(:,:,:)
    integer(is)                :: iscratch
    character(len=60)          :: buffile
    
    ! Everything else
    integer(is)                :: i,j,k,n,imo,i1
    integer(is)                :: n_int_I,nmoI,n1h,n2h
    real(dp)                   :: eph
    
!----------------------------------------------------------------------
! Is this a CVS-MRCI calculation
!----------------------------------------------------------------------
    if (sum(icvs) > 0) then
       lcvs=.true.
    else
       lcvs=.false.
    endif
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    nmoI=cfgM%nmoI
    n_int_I=cfgM%n_int_I
    n1h=cfgM%n1h
    n2h=cfgM%n2h

    allocate(keyI(n_int_I,2))
    keyI=0_ib
    
    allocate(socc(nmoI),docc(nmoI),unocc(nmoI))
    socc=0; docc=0; unocc=0
    
    allocate(ibuffer(2,bufsize))
    ibuffer=0

    allocate(cbuffer(n_int_I,2,bufsize))
    cbuffer=0_ib

!----------------------------------------------------------------------
! Open the buffer file
!----------------------------------------------------------------------
    call freeunit(iscratch)
    call scratch_name('1h1Iconf',buffile)
    open(iscratch,file=buffile,form='unformatted',status='unknown')
    
!----------------------------------------------------------------------
! Initialise the hash table
!----------------------------------------------------------------------
    initial_size=min(n2h*(nel-1)/2,1024)
    call h%initialise_table(initial_size)

!----------------------------------------------------------------------
! Insert the 1-hole configurations
! These will be deleted before the keys are retrieved from the hash
! table, and serve only to filter out replications when the internal
! creation operators are applied to the 2-hole configurations
!----------------------------------------------------------------------
    ! Loop over 1-hole configurations
    do n=1,n1h

       ! Insert the 1-hole configuration
       key=0_ib
       key(1:n_int_I,:)=cfgM%conf1h(:,:,n)
       call h%insert_key(key)
       
    enddo

!----------------------------------------------------------------------
! Generate the 1-hole, 1I configurations
!----------------------------------------------------------------------
    ! Initialise the buffer variables
    nold=h%n_keys_stored
    nbuf=0
    nrec=0
    
    ! Loop over 2-hole configurations
    do n=1,n2h

       ! 1H1I configurations generated from the current
       ! 2-hole configuration
       do imo=1,nmoI

          ! Cycle if this is a CVS-MRCI calculation and we are creating
          ! an electron in a flagged core MO
          if (lcvs .and. icvs(cfgM%m2c(imo)) == 1) cycle
          
          ! Block index
          k=(imo-1)/64+1
          
          ! Postion of the external MO within the kth block
          i=imo-(k-1)*64-1          

          ! Cycle if this MO is doubly-occupied
          if (btest(cfgM%conf2h(k,2,n),i)) cycle

          ! Create the 1H1I configuration
          key=0_ib
          key(1:n_int_I,:)=cfgM%conf2h(:,:,n)
          if (btest(cfgM%conf2h(k,1,n),i)) then
             key(k,2)=ibset(key(k,2),i)
          else
             key(k,1)=ibset(key(k,1),i)
          endif

          ! Cycle if this 1H1I configuration cannot possibly
          ! generate DFT/MRCI confs satisfying the energy selection
          ! criterion
          if (ldftmrci) then
             if (eparticle_hole(key,n_int,cfgM%m2c) > E0max+desel) cycle 
          endif
             
          ! Hash table insertion
          call h%insert_key(key)

          ! If this is a unique configuration, then save it
          if (h%n_keys_stored > nold) then
             keyI=key(1:n_int_I,:)
             call save_1h1I(nold,h%n_keys_stored,nbuf,n_int_I,&
                  ibuffer,cbuffer,iscratch,nrec,n,imo,keyI)
          endif
             
       enddo
       
    enddo

!----------------------------------------------------------------------
! Get the number of 1H1I configurations and allocate arrays
!----------------------------------------------------------------------
    ! Number of keys stored in the hash table minus those
    ! corresponding to the 1-hole configurations
    n1h1I=h%n_keys_stored-n1h

    ! Allocate arrays
    allocate(conf1h1I(n_int_I,2,n1h1I))
    conf1h1I=0_ib
    allocate(indx1h1I(2,n1h1I))
    indx1h1I=0
    
!----------------------------------------------------------------------
! Load the 1H1I configurations from the buffer
!----------------------------------------------------------------------
    call load_1h1I(indx1h1I,conf1h1I,n1h1I,n_int_I,ibuffer,cbuffer,&
         nrec,nbuf,iscratch)
    
!----------------------------------------------------------------------
! Delete the hash table
!----------------------------------------------------------------------
    call h%delete_table

!----------------------------------------------------------------------
! Close the buffer file
!----------------------------------------------------------------------
    close(iscratch)
 
!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(ibuffer)
    deallocate(cbuffer)
    deallocate(keyI)
    deallocate(socc,docc,unocc)
    
    return
    
  end subroutine generate_1hole_1I_confs

!######################################################################
! save_1h1I: buffered saving of the 1H1I configurations
!######################################################################
  subroutine save_1h1I(nold,n_keys_stored,nbuf,n_int_I,ibuffer,&
       cbuffer,iscratch,nrec,i2h,imo,conf)

    use bitglobal
    use constants
    
    implicit none

    integer(is), intent(out)   :: nold
    integer(ib), intent(in)    :: n_keys_stored
    integer(is), intent(inout) :: nbuf
    integer(is), intent(in)    :: n_int_I
    integer(is), intent(inout) :: ibuffer(2,bufsize)
    integer(ib), intent(inout) :: cbuffer(n_int_I,2,bufsize)
    integer(is), intent(in)    :: iscratch
    integer(is), intent(inout) :: nrec
    integer(is), intent(in)    :: i2h,imo
    integer(ib), intent(in)    :: conf(n_int_I,2)
    
    !
    ! Update the number of entries in the buffer
    !
    nbuf=nbuf+1

    !
    ! Number of confs generated up to this point
    !
    nold=n_keys_stored

    !
    ! Store the index-pair in the buffer
    !
    ibuffer(1,nbuf)=i2h
    ibuffer(2,nbuf)=imo

    !
    ! Store the configuration bit string in the buffer
    !
    cbuffer(:,:,nbuf)=conf
    
    !
    ! If the buffer is full, then write it to disk and reset
    ! the buffer
    !
    if (nbuf == bufsize) then

       ! Increment the record counter
       nrec=nrec+1

       ! Write the buffer to disk
       write(iscratch) ibuffer
       write(iscratch) cbuffer
       
       ! Reset the buffer
       nbuf=0
       ibuffer=0
       cbuffer=0_ib
       
    endif
    
    return
        
  end subroutine save_1h1I

!######################################################################
! load_1h1I: loads the stored 1H1I configurations into memory
!######################################################################
  subroutine load_1h1I(indx1h1I,conf1h1I,n1h1I,n_int_I,ibuffer,&
       cbuffer,nrec,nbuf,iscratch)

    use bitglobal
    use constants
    
    implicit none

    integer(is), intent(in)  :: n1h1I,nrec,nbuf,iscratch
    integer(is), intent(in)  :: n_int_I
    integer(is), intent(out) :: indx1h1I(2,n1h1I)
    integer(ib), intent(out) :: conf1h1I(n_int_I,2,n1h1I)
    integer(is), intent(in)  :: ibuffer(2,bufsize)
    integer(ib), intent(in)  :: cbuffer(n_int_I,2,bufsize)
    integer(is)              :: i,counter,lim1,lim2
    
    !
    ! Rewind to the start of the scratch file
    !
    rewind(iscratch)
    
    !
    ! Indices written to disk
    !
    counter=0
    do i=1,nrec
       counter=counter+1
       lim1=(counter-1)*bufsize+1
       lim2=counter*bufsize
       read(iscratch) indx1h1I(:,lim1:lim2)
       read(iscratch) conf1h1I(:,:,lim1:lim2)
    enddo

    !
    ! Remaining indices in the buffer
    !
    lim1=nrec*bufsize+1
    lim2=nrec*bufsize+nbuf
    indx1h1I(:,lim1:lim2)=ibuffer(:,1:nbuf)
    conf1h1I(:,:,lim1:lim2)=cbuffer(:,:,1:nbuf)
    
    return
    
  end subroutine load_1h1I

!######################################################################
! ehole: returns the sum of the negatives of the energies of the hole
!        MOs (relative the base configuration)
!######################################################################
  function ehole(conf,ldc,m2c)

    use constants
    use bitglobal
    use mrciutils

    implicit none

    ! Function result
    real(dp)                :: ehole
    
    ! Configuration
    integer(is), intent(in) :: ldc
    integer(ib), intent(in) :: conf(ldc,2)

    ! MO mapping array
    integer(is), intent(in) :: m2c(nmo)
    
    ! Difference configuration information
    integer(is)             :: Dw(nmo,2)
    integer(is)             :: ndiff

    ! Everything else
    integer(is)             :: i,i1,Dwi

    !
    ! Difference configuration information
    !
    call diffconf(conf,ldc,Dw,nmo,ndiff)

    !
    ! Sum the hole MO energies multiplied by the occupation differences
    !
    ehole=0.0d0
    do i=1,ndiff
       i1=m2c(Dw(i,1))
       Dwi=Dw(i,2)
       if (Dwi < 0) ehole=ehole+moen(i1)*Dwi
    enddo
    
    return
    
  end function ehole

!######################################################################
! eparticle_hole: returns the sum of the absolutes of the energies of
!                 hole and particle MOs (relative the base
!                 configuration)
!######################################################################
  function eparticle_hole(conf,ldc,m2c)

    use constants
    use bitglobal
    use mrciutils

    implicit none

    ! Function result
    real(dp)                :: eparticle_hole
    
    ! Configuration
    integer(is), intent(in) :: ldc
    integer(ib), intent(in) :: conf(ldc,2)

    ! MO mapping array
    integer(is), intent(in) :: m2c(nmo)
    
    ! Difference configuration information
    integer(is)             :: Dw(nmo,2)
    integer(is)             :: ndiff

    ! Everything else
    integer(is)             :: i,i1,Dwi

    !
    ! Difference configuration information
    !
    call diffconf(conf,ldc,Dw,nmo,ndiff)

    !
    ! Sum the MO energies multiplied by the occupation differences
    !
    eparticle_hole=0.0d0
    do i=1,ndiff
       i1=m2c(Dw(i,1))
       Dwi=Dw(i,2)
       eparticle_hole=eparticle_hole+moen(i1)*Dwi
    enddo
    
    return
    
  end function eparticle_hole

!######################################################################
! filter_hole_confs: removes any hole configurations which do not
!                    generate any full configurations
!######################################################################
  subroutine filter_hole_confs(cfgM)

    use constants
    use bitglobal
    use conftype
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(inout) :: cfgM
    
!----------------------------------------------------------------------
! 1-hole configurations
!----------------------------------------------------------------------
    call filter_1hole_confs(cfgM)

!----------------------------------------------------------------------
! 2-hole configurations
!----------------------------------------------------------------------
    call filter_2hole_confs(cfgM)

    return
    
  end subroutine filter_hole_confs

!######################################################################
! filter_1hole_confs: removes any 1-hole configurations which do not
!                     generate any full configurations
!######################################################################
  subroutine filter_1hole_confs(cfgM)

    use constants
    use bitglobal
    use conftype
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(inout) :: cfgM

    ! Working arrays
    integer(ib), allocatable   :: conftmp(:,:,:)
    integer(is), allocatable   :: offtmp1I(:),offtmp1E(:)
    integer(is), allocatable   :: offtmp1h(:)
    integer(is), allocatable   :: ngen(:)
    
    ! Everything else
    integer(is)                :: n,iref,nok,counter,nlastI,nlastE,&
                                  countlastI,countlastE

!----------------------------------------------------------------------
! Determine the number of 1-hole configurations that generate full
! configurations
!----------------------------------------------------------------------
    nok=0
    
    ! Loop over 1-hole configurations
    do n=1,cfgM%n1h

       ! Does the current 1-hole configuration generate any 1I or
       ! 1E configurations?
       if (cfgM%off1I(n) /= cfgM%off1I(n+1) &
            .or. cfgM%off1E(n) /= cfgM%off1E(n+1)) nok=nok+1

    enddo
    
!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(conftmp(cfgM%n_int_I,2,nok))
    conftmp=0_ib

    allocate(offtmp1I(nok+1))
    offtmp1I=0
    
    allocate(offtmp1E(nok+1))
    offtmp1E=0

    allocate(ngen(cfgM%nR))
    ngen=0

!----------------------------------------------------------------------
! Re-fill the off1h array
!----------------------------------------------------------------------
    ! Loop over reference configurations
    do iref=1,cfgM%nR

       ! Loop over the 1-hole configurations generated by the current
       ! reference configuration
       do n=cfgM%off1h(iref),cfgM%off1h(iref+1)-1

          ! Does the current 1-hole configuration generate any 1I
          ! or 1E configurations?
          if (cfgM%off1I(n) /= cfgM%off1I(n+1) &
               .or. cfgM%off1E(n) /= cfgM%off1E(n+1)) then

             ! Update the no. 1-hole configurations generated by
             ! the current reference configuration
             ngen(iref)=ngen(iref)+1
             
          endif
             
       enddo

    enddo

    ! Re-fill the off1h offset array
    cfgM%off1h(1)=1
    do n=2,cfgM%nR+1
       cfgM%off1h(n)=cfgM%off1h(n-1)+ngen(n-1)
    enddo
    
!----------------------------------------------------------------------
! Filter out the 1-hole configurations that don't generate any full
! configurations
!----------------------------------------------------------------------
    counter=0
    
    ! Loop over 1-hole configurations
    do n=1,cfgM%n1h

       ! Does the current 1-hole configuration generate any 1I or
       ! 1E configurations?
       if (cfgM%off1I(n) /= cfgM%off1I(n+1) &
            .or. cfgM%off1E(n) /= cfgM%off1E(n+1)) then

          ! Increment the OK 1-hole conf counter
          counter=counter+1

          ! Save the 1-hole conf
          conftmp(:,:,counter)=cfgM%conf1h(:,:,n)

          ! Save the 1I offset
          offtmp1I(counter)=cfgM%off1I(n)
          
          ! Save the 1E offset
          offtmp1E(counter)=cfgM%off1E(n)

          ! End point of the 1-hole confs that generate
          ! 1I and 1E confs
          if (cfgM%off1I(n) /= cfgM%off1I(n+1)) then
             nlastI=n
             countlastI=counter
          endif
          if (cfgM%off1E(n) /= cfgM%off1E(n+1)) then
             nlastE=n
             countlastE=counter
          endif
             
       endif
       
    enddo

    ! Final offsets
    if (cfgM%n1I > 0) &
         offtmp1I(countlastI+1:nok+1)=cfgM%off1I(nlastI+1)

    if (cfgM%n1E > 0) &
         offtmp1E(countlastE+1:nok+1)=cfgM%off1E(nlastE+1)

!----------------------------------------------------------------------
! Re-allocate and fill in the 1-hole conf and offset arrays
!----------------------------------------------------------------------
    cfgM%n1h=nok

    deallocate(cfgM%conf1h)
    deallocate(cfgM%off1I)
    deallocate(cfgM%off1E)

    allocate(cfgM%conf1h(cfgM%n_int_I,2,nok))
    allocate(cfgM%off1I(nok+1))
    allocate(cfgM%off1E(nok+1))

    cfgM%conf1h=conftmp
    cfgM%off1I=offtmp1I
    cfgM%off1E=offtmp1E

!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(conftmp)
    deallocate(offtmp1I)
    deallocate(offtmp1E)
    deallocate(ngen)
    
    return
    
  end subroutine filter_1hole_confs
    
!######################################################################
! filter_2hole_confs: removes any 2-hole configurations which do not
!                     generate any full configurations
!######################################################################
  subroutine filter_2hole_confs(cfgM)

    use constants
    use bitglobal
    use conftype
    
    implicit none

    ! MRCI configuration derived type
    type(mrcfg), intent(inout) :: cfgM

    ! Working arrays
    integer(ib), allocatable   :: conftmp(:,:,:)
    integer(is), allocatable   :: offtmp2I(:),offtmp2E(:),&
                                  offtmp1I1E(:)
    integer(is), allocatable   :: ngen(:)
    
    ! Everything else
    integer(is)                :: n,iref,nok,counter,nlast2I,nlast2E,&
                                  nlast1I1E,countlast2I,countlast2E,&
                                  countlast1I1E
    
!----------------------------------------------------------------------
! Determine the number of 2-hole configurations that generate full
! configurations
!----------------------------------------------------------------------
    nok=0

    ! Loop over 2-hole configurations
    do n=1,cfgM%n2h

       ! Does the current 2-hole configuration generate any 2I, 2E
       ! or 1I1E configurations?
       if (cfgM%off2I(n) /= cfgM%off2I(n+1) &
            .or. cfgM%off2E(n) /= cfgM%off2E(n+1) &
            .or. cfgM%off1I1E(n) /= cfgM%off1I1E(n+1)) nok=nok+1
       
    enddo

!----------------------------------------------------------------------
! Allocate arrays
!----------------------------------------------------------------------
    allocate(conftmp(cfgM%n_int_I,2,nok))
    conftmp=0_ib

    allocate(offtmp2I(nok+1))
    offtmp2I=0
    
    allocate(offtmp2E(nok+1))
    offtmp2E=0

    allocate(offtmp1I1E(nok+1))
    offtmp1I1E=0

    allocate(ngen(cfgM%nR))
    ngen=0

!----------------------------------------------------------------------
! Re-fill the off2h array
!----------------------------------------------------------------------
    ! Loop over reference configurations
    do iref=1,cfgM%nR

       ! Loop over the 2-hole configurations generated by the current
       ! reference configuration
       do n=cfgM%off2h(iref),cfgM%off2h(iref+1)-1

          ! Does the current 2-hole configuration generate any 2I, 2E
          ! or 1I1E configurations?
          if (cfgM%off2I(n) /= cfgM%off2I(n+1) &
               .or. cfgM%off2E(n) /= cfgM%off2E(n+1) &
               .or. cfgM%off1I1E(n) /= cfgM%off1I1E(n+1)) then

             ! Update the no. 2-hole configurations generated by
             ! the current reference configuration
             ngen(iref)=ngen(iref)+1
             
          endif
             
       enddo

    enddo

    ! Re-fill the off2h offset array
    cfgM%off2h(1)=1
    do n=2,cfgM%nR+1
       cfgM%off2h(n)=cfgM%off2h(n-1)+ngen(n-1)
    enddo
    
!----------------------------------------------------------------------
! Filter out the 2-hole configurations that don't generate any full
! configurations
!----------------------------------------------------------------------
    counter=0

    ! Loop over 2-hole configurations
    do n=1,cfgM%n2h

       ! Does the current 2-hole configuration generate any 2I, 2E
       ! or 1I1E configurations?
       if (cfgM%off2I(n) /= cfgM%off2I(n+1) &
            .or. cfgM%off2E(n) /= cfgM%off2E(n+1) &
            .or. cfgM%off1I1E(n) /= cfgM%off1I1E(n+1)) then

          ! Increment the OK 2-hole conf counter
          counter=counter+1

          ! Save the 2-hole conf
          conftmp(:,:,counter)=cfgM%conf2h(:,:,n)

          ! Save the 2I offset
          offtmp2I(counter)=cfgM%off2I(n)
          
          ! Save the 2E offset
          offtmp2E(counter)=cfgM%off2E(n)

          ! Save the 1I1E offset
          offtmp1I1E(counter)=cfgM%off1I1E(n)

          ! End point of the 2-hole confs that generate
          ! 2I, 2E and 1I1E confs
          if (cfgM%off2I(n) /= cfgM%off2I(n+1)) then
             nlast2I=n
             countlast2I=counter
          endif
          if (cfgM%off2E(n) /= cfgM%off2E(n+1)) then
             nlast2E=n
             countlast2E=counter
          endif
          if (cfgM%off1I1E(n) /= cfgM%off1I1E(n+1)) then
             nlast1I1E=n
             countlast1I1E=counter
          endif
          
       endif

    enddo

    ! Final offsets
    if (cfgM%n2I > 0) &
         offtmp2I(countlast2I+1:nok+1)=cfgM%off2I(nlast2I+1)

    if (cfgM%n2E > 0) &
         offtmp2E(countlast2E+1:nok+1)=cfgM%off2E(nlast2E+1)

    if (cfgM%n1I1E > 0) &
         offtmp1I1E(countlast1I1E+1:nok+1)=cfgM%off1I1E(nlast1I1E+1)
    
!----------------------------------------------------------------------
! Re-allocate and fill in the 2-hole conf and offset arrays
!----------------------------------------------------------------------
    cfgM%n2h=nok

    deallocate(cfgM%conf2h)
    deallocate(cfgM%off2I)
    deallocate(cfgM%off2E)
    deallocate(cfgM%off1I1E)

    allocate(cfgM%conf2h(cfgM%n_int_I,2,nok))
    allocate(cfgM%off2I(nok+1))
    allocate(cfgM%off2E(nok+1))
    allocate(cfgM%off1I1E(nok+1))

    cfgM%conf2h=conftmp
    cfgM%off2I=offtmp2I
    cfgM%off2E=offtmp2E
    cfgM%off1I1E=offtmp1I1E
    
!----------------------------------------------------------------------
! Deallocate arrays
!----------------------------------------------------------------------
    deallocate(conftmp)
    deallocate(offtmp2I)
    deallocate(offtmp2E)
    deallocate(offtmp1I1E)
    deallocate(ngen)
    
    return

  end subroutine filter_2hole_confs
  
!######################################################################
  
end module holeconfs
