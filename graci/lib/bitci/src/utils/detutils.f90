module detutils

  implicit none

contains

!######################################################################
! n_alpha_electrons: given a determinant d, returns the number of
!                    alpha electrons
!######################################################################
  function n_alpha_electrons(d) result(nalpha)

    use constants
    use bitglobal
    
    implicit none

    integer(is)             :: nalpha
    integer(ib), intent(in) :: d(n_int,2)
    integer(is)             :: k

    nalpha=0
    do k=1,n_int
       nalpha=nalpha+popcnt(d(k,1))
    enddo
    
    return
    
  end function n_alpha_electrons

!######################################################################
! n_beta_electrons: given a determinant d, returns the number of
!                   beta electrons
!######################################################################
  function n_beta_electrons(d) result(nbeta)

    use constants
    use bitglobal
    
    implicit none

    integer(is)             :: nbeta
    integer(ib), intent(in) :: d(n_int,2)
    integer(is)             :: k

    nbeta=0
    do k=1,n_int
       nbeta=nbeta+popcnt(d(k,2))
    enddo
       
    return
    
  end function n_beta_electrons

!######################################################################
! homo_index: given a determinant d, returns the index of the HOMO
!######################################################################
  function homo_index(d) result(ihomo)

    use constants
    use bitglobal
    use bitutils
    
    implicit none

    integer(ib), intent(in) :: d(n_int,2)
    integer(is)             :: ihomo
    integer(is)             :: k,ispin,n,msb
    integer(is)             :: ihighest(2)
        
    !
    ! Get the index of the HOMO
    !
    ihighest=0
    do ispin=1,2
       do k=1,n_int
          if (popcnt(d(k,ispin)).eq.0) cycle
          msb=most_significant_bit(d(k,ispin))
          ihighest(ispin)=msb+(k-1)*64
       enddo
    enddo
    ihomo=maxval(ihighest)

    return

  end function homo_index
    
!######################################################################
! get_sop: given a determinant d, computes the associated spatial
!          occupation pattern (SOP)
!######################################################################
  subroutine get_sop(d,sop)

    use constants
    use bitglobal
    
    implicit none

    integer(ib), intent(in)    :: d(n_int,2)   ! Input determinant
    integer(ib), intent(inout) :: sop(n_int,2) ! Output SOP
    integer(is)                :: k
  
    ! Loop over elements of the determinant array
    do k=1,n_int
     
       ! Encoding of the singly-occupied orbitals
       sop(k,1)=ieor(d(k,1),d(k,2))
       
       ! Encoding of the doubly-occupied orbitals
       sop(k,2)=iand(d(k,1),d(k,2))
       
    enddo
  
    return
  
  end subroutine get_sop

!######################################################################
! ndet_tot: for a given SOP, returns the total number of determinants
!           that can be generated from it
!######################################################################
  function ndet_tot(sop,nalpha)

    use constants
    use bitglobal
    use math
    
    implicit none

    integer(is) :: ndet_tot
    
    integer(ib), intent(in) :: sop(n_int,2) ! Input SOP
    integer(is), intent(in) :: nalpha       ! No. alpha electrons
    integer(is)             :: k,l
    integer(is)             :: nopen,ndocc,nua

    !
    ! Number of open shell spatial orbitals
    !
    nopen=0
    do k=1,n_int
       nopen=nopen+popcnt(sop(k,1))
    enddo

    !
    ! Number of doubly-occupied spatial orbitals
    !
    ndocc=0
    do k=1,n_int
       ndocc=ndocc+popcnt(sop(k,2))
    enddo

    !
    ! Number of unpaired alpha electrons
    !
    nua=nalpha-ndocc

    !
    ! Total number of determinants generated by the SOP
    !
    ndet_tot=int(bico(nopen,nua))
    
    return
    
  end function ndet_tot
    
!######################################################################
! get_occ: given a determinant, d, returns the indices of the occupied
!          alpha and beta orbitals
!######################################################################
  subroutine get_occ(d,occ)

    use constants
    use bitglobal
    
    implicit none

    integer(ib), intent(in)    :: d(n_int,2)
    integer(is), intent(inout) :: occ(nmo,2)
    integer(is)                :: ic,k,ipos,ispin
    integer(ib)                :: h

    !
    ! Initialisation
    !
    occ=0
    
    !
    ! Get the indices of the occupied alpha and beta orbitals
    !
    ! Loop over alpha and beta spins
    do ispin=1,2

       ! Initialise the orbital counter
       ic=1

       ! Loop over bit string blocks for the current spin
       do k=1,n_int

          ! Initialise the work array
          h=d(k,ispin)

          ! Get the occupied orbital indices for this block
          do while (h.ne.0_ib)

             ! Number of trailing zeros left in h
             ipos=trailz(h)

             ! Index of the next occupied orbital
             occ(ic,ispin)=1+ipos+(k-1)*64

             ! Clear the bits up to the occupied orbital in h
             h=ibclr(h,ipos)

             ! Increment the orbital counter
             ic=ic+1
             
          enddo
          
       enddo

    enddo
    
    return
    
  end subroutine get_occ

!######################################################################
! get_unocc: given a determinant, d, returns the indices of the
!            unoccupied alpha and beta orbitals
!######################################################################
  subroutine get_unocc(d,unocc)

    use constants
    use bitglobal
    
    implicit none

    integer(ib), intent(in)    :: d(n_int,2)
    integer(is), intent(inout) :: unocc(nmo,2)
    integer(is)                :: ic,k,ipos,ispin,imo
    integer(ib)                :: h,u
    
    !
    ! Get the indices of the unoccupied alpha and beta orbitals
    !
    ! Loop over alpha and beta spins
    do ispin=1,2
       
       ! Initialise the orbital counter
       ic=1

       ! Loop over bit string blocks for the current spin
       do k=1,n_int

          ! Swap all bit values
          u=not(d(k,ispin))
          
          ! Initialise the work array
          h=u

          ! Get the unoccupied orbital indices for this block
          do while (h.ne.0_ib)

             ! Number of trailing zeros left in h
             ipos=trailz(h)

             ! Exit if we have reached the end of the MOs in the basis
             ! This will happen when nmo/64 is not an integer
             imo=1+ipos+(k-1)*64
             if (imo.gt.nmo) exit
             
             ! Index of the next occupied orbital
             unocc(ic,ispin)=imo
             
             ! Clear the bits up to the occupied orbital in h
             h=ibclr(h,ipos)

             ! Increment the orbital counter
             ic=ic+1

          enddo

       enddo

    enddo

    return
    
  end subroutine get_unocc

!######################################################################
! det_hash: hash of the bit string representation of a determinant
!           using the MurmerHash3 32-bit hash function
!######################################################################
  function det_hash(det) result(hash)

    use constants
    
    implicit none

    integer(ib)             :: hash
    
    integer(ib), intent(in) :: det(n_int,2)

    integer(is)             :: chunks(4*n_int)
    integer(is)             :: len
    integer(is)             :: seed
    integer(is)             :: i,j,k,t

    ! Bit masks
    integer(ib), parameter  :: mask1=4294967295_ib  ! 11...100...0
    integer(ib), parameter  :: mask2=-4294967296_ib ! 00...011...1

    ! MurmurHash3 32-bit hash function parameters
    integer(is), parameter  :: c1=-862048943 ! 0xcc9e2d51
    integer(is), parameter  :: c2=461845907  ! 0x1b873593
    integer(is), parameter  :: m=5
    integer(is), parameter  :: n=430675100   ! 0xe6546b64
    integer(is), parameter  :: p=-2048144789 ! 0x85ebca6b
    integer(is), parameter  :: q=-1028477387 ! 0xc2b2ae35
    integer(is), parameter  :: r1=15
    integer(is), parameter  :: r2=13

!----------------------------------------------------------------------
! Split the 64-bit bit strings into 32-bit chunks
!----------------------------------------------------------------------
    j=0
    do k=1,2
       do i=1,n_int
          j=j+1
          chunks(j)=iand(mask1,det(i,k))
          j=j+1
          chunks(j)=ishft(iand(mask2,det(i,k)),-32)
       enddo
    enddo
    
!----------------------------------------------------------------------    
! Compute the hash function value
!----------------------------------------------------------------------
    seed=0
    len=16*n_int

    t=seed

    do i=1,4*n_int
       k=chunks(i)
       k=k*c1
       k=ishftc(k,r1)
       k=k*c2
       t=ieor(t,k)
       t=ishftc(t,r2)
       t=t*m-n
    enddo

    t=ieor(t,len)

    t=ieor(t,ishft(t,-16))
    t=t*p
    t=ieor(t,ishft(t,-13))
    t=t*q
    t=ieor(t,ishft(t,-16))
    
    hash=t

    return
    
  end function det_hash
  
!######################################################################
! det_sym: given a determinant d, returns the integer label of the
!          irrep that it generates
!######################################################################
  function det_sym(d)

    use constants
    use bitglobal
    
    implicit none

    integer(is)             :: det_sym
    integer(ib), intent(in) :: d(n_int,2)
    integer(ib)             :: sop(n_int,2)
    integer(is)             :: k,ipos,imo
    integer(ib)             :: h,isym
    
    !
    ! Generate the spatial occupation pattern for the determinant
    !
    call get_sop(d,sop)

    !
    ! Direct product of the irreps generated by the singly-occupied
    ! orbitals
    !
    ! Initialisation to the totally symmetric irrep (which is always
    ! encoded as 0)
    isym=0_ib
    
    ! Loop over blocks
    do k=1,n_int

       ! Initialise the work array
       h=sop(k,1)

       ! Loop over the singly-occupied orbital indices
       do while (h.ne.0_ib)

          ! Number of trailing zeros left in h
          ipos=trailz(h)

          ! Index of the next singly-occupied orbital
          imo=1+ipos+(k-1)*64

          ! Direct product
          isym=ieor(mosym(imo),isym)
          
          ! Clear the bits up to the current singly-occupied orbital
          h=ibclr(h,ipos)
          
       enddo
          
    enddo

    det_sym=isym
    
    return
    
  end function det_sym
  
!######################################################################
! write_det_string: writes the determinant d to the character string
!                   string in the format 2...0...u...d...
!######################################################################
  subroutine write_det_string(d,string)
  
    use constants
    use bitglobal
  
    implicit none

    integer(ib), intent(in)       :: d(n_int,2)
    character(len=*), intent(out) :: string
    integer(is)                   :: ihomo,imo,i,k,occa,occb,occ
    
    !
    ! Initialisation
    !
    string=''

    !
    ! Index of the highest occupied orbital
    !
    ihomo=homo_index(d)

    !
    ! Write the determinant character string
    !
    do imo=1,ihomo

       ! Block index
       k=(imo-1)/64+1
       
       ! Orbital position with the block
       i=imo-1-(k-1)*64

       ! Alpha-spin occupancy
       if (btest(d(k,1),i)) then
          occa=1
       else
          occa=0
       endif
       
       ! Beta-spin occupancy
       if (btest(d(k,2),i)) then
          occb=1
       else
          occb=0
       endif

       ! Total occupancy
       occ=occa+occb

       ! Write the total occupancy to the character string
       if (occ.eq.2) then
          write(string(imo:imo),'(a1)') '2'
       else if (occ.eq.0) then
          write(string(imo:imo),'(a1)') '0'
       else
          if (occa.eq.1) then
             write(string(imo:imo),'(a1)') 'u'
          else
             write(string(imo:imo),'(a1)') 'd'
          endif
       endif
       
    enddo

    return
    
  end subroutine write_det_string
  
!######################################################################
  
end module detutils
